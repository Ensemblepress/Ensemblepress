import {
  require_signal_exit
} from "./chunk-JIJ65JT6.js";
import {
  require_isexe
} from "./chunk-SAR5HGRG.js";
import {
  __commonJS,
  __require,
  init_cjs_shims
} from "./chunk-ZPL24Y2D.js";

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/helpers.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeOptions = exports.arrayifyInput = exports.isNullOrUndefined = void 0;
    function isNullOrUndefined(input) {
      if (input === void 0 || input === null) {
        return true;
      }
      return false;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function arrayifyInput(input) {
      return Array.isArray(input) ? input : [input];
    }
    exports.arrayifyInput = arrayifyInput;
    function mergeOptions(options) {
      const defaultOptions = {
        signal: "SIGKILL"
      };
      return Object.assign(Object.assign({}, defaultOptions), options);
    }
    exports.mergeOptions = mergeOptions;
  }
});

// ../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js"(exports, module) {
    init_cjs_shims();
    module.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = __require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// ../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/pseudomap.js"(exports, module) {
    init_cjs_shims();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});

// ../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/map.js
var require_map = __commonJS({
  "../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/map.js"(exports, module) {
    init_cjs_shims();
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module.exports = Map;
    } else {
      module.exports = require_pseudomap();
    }
  }
});

// ../../node_modules/.pnpm/yallist@2.1.2/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/.pnpm/yallist@2.1.2/node_modules/yallist/yallist.js"(exports, module) {
    init_cjs_shims();
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});

// ../../node_modules/.pnpm/lru-cache@4.1.5/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/.pnpm/lru-cache@4.1.5/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = LRUCache;
    var Map2 = require_map();
    var util = __require("util");
    var Yallist = require_yallist();
    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    var MAX = makeSymbol("max");
    var LENGTH = makeSymbol("length");
    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
    var ALLOW_STALE = makeSymbol("allowStale");
    var MAX_AGE = makeSymbol("maxAge");
    var DISPOSE = makeSymbol("dispose");
    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
    var LRU_LIST = makeSymbol("lruList");
    var CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options);
      }
      if (typeof options === "number") {
        options = { max: options };
      }
      if (!options) {
        options = {};
      }
      var max = this[MAX] = options.max;
      if (!max || !(typeof max === "number") || max <= 0) {
        this[MAX] = Infinity;
      }
      var lc = options.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      this[LENGTH_CALCULATOR] = lc;
      this[ALLOW_STALE] = options.stale || false;
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        this[MAX] = mL;
        trim(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        this[MAX_AGE] = mA;
        trim(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function(hit) {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          }, this);
        }
        trim(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function(hit) {
          this[DISPOSE](hit.key, hit.value);
        }, this);
      }
      this[CACHE] = new Map2();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = this[ALLOW_STALE];
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = this[MAX];
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util.inspect(max, opts);
        extras = true;
      }
      var maxAge = this[MAX_AGE];
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util.inspect(maxAge, opts);
        extras = true;
      }
      var lc = this[LENGTH_CALCULATOR];
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util.inspect(this[LENGTH], opts);
        extras = true;
      }
      var didFirst = false;
      this[LRU_LIST].forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util.inspect(item.key).split("\n").join("\n  ");
        var val = { value: item.value };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) {
            this[DISPOSE](key, item.value);
          }
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) {
          this[DISPOSE](key, value);
        }
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return false;
      var hit = this[CACHE].get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self = this;
      this[CACHE].forEach(function(value, key) {
        get(self, key, false);
      });
    };
    function get(self, key, doUse) {
      var node = self[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            hit = void 0;
        } else {
          if (doUse) {
            self[LRU_LIST].unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self, hit) {
      if (!hit || !hit.maxAge && !self[MAX_AGE]) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self[MAX_AGE] && diff > self[MAX_AGE];
      }
      return stale;
    }
    function trim(self) {
      if (self[LENGTH] > self[MAX]) {
        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    }
    function del(self, node) {
      if (node) {
        var hit = node.value;
        if (self[DISPOSE]) {
          self[DISPOSE](hit.key, hit.value);
        }
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path");
    var which = require_which();
    var LRU = require_lru_cache();
    var commandCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function resolveCommand(command, noExtension) {
      var resolved;
      noExtension = !!noExtension;
      resolved = commandCache.get(command + "!" + noExtension);
      if (commandCache.has(command)) {
        return commandCache.get(command);
      }
      try {
        resolved = !noExtension ? which.sync(command) : which.sync(command, { pathExt: path.delimiter + (process.env.PATHEXT || "") });
      } catch (e) {
      }
      commandCache.set(command + "!" + noExtension, resolved);
      return resolved;
    }
    module.exports = resolveCommand;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js
var require_hasEmptyArgumentBug = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function hasEmptyArgumentBug() {
      var nodeVer;
      if (process.platform !== "win32") {
        return false;
      }
      nodeVer = process.version.substr(1).split(".").map(function(num) {
        return parseInt(num, 10);
      });
      return nodeVer[0] === 0 && nodeVer[1] < 12;
    }
    module.exports = hasEmptyArgumentBug();
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeArgument.js
var require_escapeArgument = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeArgument.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function escapeArgument(arg, quote) {
      arg = "" + arg;
      if (!quote) {
        arg = arg.replace(/([()%!^<>&|;,"'\s])/g, "^$1");
      } else {
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, "$1$1");
        arg = '"' + arg + '"';
      }
      return arg;
    }
    module.exports = escapeArgument;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeCommand.js
var require_escapeCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeCommand.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var escapeArgument = require_escapeArgument();
    function escapeCommand(command) {
      return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArgument(command, true);
    }
    module.exports = escapeCommand;
  }
});

// ../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = /^#!.*/;
  }
});

// ../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var shebangRegex = require_shebang_regex();
    module.exports = function(str) {
      var match = str.match(shebangRegex);
      if (!match) {
        return null;
      }
      var arr = match[0].replace(/#! ?/, "").split(" ");
      var bin = arr[0].split("/").pop();
      var arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs = __require("fs");
    var LRU = require_lru_cache();
    var shebangCommand = require_shebang_command();
    var shebangCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function readShebang(command) {
      var buffer;
      var fd;
      var shebang;
      if (shebangCache.has(command)) {
        return shebangCache.get(command);
      }
      buffer = new Buffer(150);
      try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, 150, 0);
        fs.closeSync(fd);
      } catch (e) {
      }
      shebang = shebangCommand(buffer.toString());
      shebangCache.set(command, shebang);
      return shebang;
    }
    module.exports = readShebang;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/parse.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var resolveCommand = require_resolveCommand();
    var hasEmptyArgumentBug = require_hasEmptyArgumentBug();
    var escapeArgument = require_escapeArgument();
    var escapeCommand = require_escapeCommand();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var skipShellRegExp = /\.(?:com|exe)$/i;
    var supportsShellOption = parseInt(process.version.substr(1).split(".")[0], 10) >= 6 || parseInt(process.version.substr(1).split(".")[0], 10) === 4 && parseInt(process.version.substr(1).split(".")[1], 10) >= 8;
    function parseNonShell(parsed) {
      var shebang;
      var needsShell;
      var applyQuotes;
      if (!isWin) {
        return parsed;
      }
      parsed.file = resolveCommand(parsed.command);
      parsed.file = parsed.file || resolveCommand(parsed.command, true);
      shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));
      } else {
        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);
      }
      if (needsShell) {
        applyQuotes = parsed.command !== "echo";
        parsed.command = escapeCommand(parsed.command);
        parsed.args = parsed.args.map(function(arg) {
          return escapeArgument(arg, applyQuotes);
        });
        parsed.args = ["/d", "/s", "/c", '"' + parsed.command + (parsed.args.length ? " " + parsed.args.join(" ") : "") + '"'];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parseShell(parsed) {
      var shellCommand;
      if (supportsShellOption) {
        return parsed;
      }
      shellCommand = [parsed.command].concat(parsed.args).join(" ");
      if (isWin) {
        parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
        parsed.args = ["/d", "/s", "/c", '"' + shellCommand + '"'];
        parsed.options.windowsVerbatimArguments = true;
      } else {
        if (typeof parsed.options.shell === "string") {
          parsed.command = parsed.options.shell;
        } else if (process.platform === "android") {
          parsed.command = "/system/bin/sh";
        } else {
          parsed.command = "/bin/sh";
        }
        parsed.args = ["-c", shellCommand];
      }
      return parsed;
    }
    function parse(command, args, options) {
      var parsed;
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = options || {};
      parsed = {
        command,
        args,
        options,
        file: void 0,
        original: command
      };
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module.exports = parse;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/enoent.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isWin = process.platform === "win32";
    var resolveCommand = require_resolveCommand();
    var isNode10 = process.version.indexOf("v0.10.") === 0;
    function notFoundError(command, syscall) {
      var err;
      err = new Error(syscall + " " + command + " ENOENT");
      err.code = err.errno = "ENOENT";
      err.syscall = syscall + " " + command;
      return err;
    }
    function hookChildProcess(cp, parsed) {
      var originalEmit;
      if (!isWin) {
        return;
      }
      originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        var err;
        if (name === "exit") {
          err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      if (isNode10 && status === -1) {
        parsed.file = isWin ? parsed.file : resolveCommand(parsed.original);
        if (!parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
      }
      return null;
    }
    module.exports.hookChildProcess = hookChildProcess;
    module.exports.verifyENOENT = verifyENOENT;
    module.exports.verifyENOENTSync = verifyENOENTSync;
    module.exports.notFoundError = notFoundError;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var cp = __require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    var cpSpawnSync = cp.spawnSync;
    function spawn(command, args, options) {
      var parsed;
      var spawned;
      parsed = parse(command, args, options);
      spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      var parsed;
      var result;
      if (!cpSpawnSync) {
        try {
          cpSpawnSync = __require("spawn-sync");
        } catch (ex) {
          throw new Error(
            "In order to use spawnSync on node 0.10 or older, you must install spawn-sync:\n\n  npm install spawn-sync --save"
          );
        }
      }
      parsed = parse(command, args, options);
      result = cpSpawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module.exports = spawn;
    module.exports.spawn = spawn;
    module.exports.sync = spawnSync;
    module.exports._parse = parse;
    module.exports._enoent = enoent;
  }
});

// ../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js
var require_strip_eof = __commonJS({
  "../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = function(x) {
      var lf = typeof x === "string" ? "\n" : "\n".charCodeAt();
      var cr = typeof x === "string" ? "\r" : "\r".charCodeAt();
      if (x[x.length - 1] === lf) {
        x = x.slice(0, x.length - 1);
      }
      if (x[x.length - 1] === cr) {
        x = x.slice(0, x.length - 1);
      }
      return x;
    };
  }
});

// ../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (opts) => {
      opts = opts || {};
      const env = opts.env || process.env;
      const platform = opts.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
    };
  }
});

// ../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path");
    var pathKey = require_path_key();
    module.exports = (opts) => {
      opts = Object.assign({
        cwd: process.cwd(),
        path: process.env[pathKey()]
      }, opts);
      let prev;
      let pth = path.resolve(opts.cwd);
      const ret = [];
      while (prev !== pth) {
        ret.push(path.join(pth, "node_modules/.bin"));
        prev = pth;
        pth = path.resolve(pth, "..");
      }
      ret.push(path.dirname(process.execPath));
      return ret.concat(opts.path).join(path.delimiter);
    };
    module.exports.env = (opts) => {
      opts = Object.assign({
        env: process.env
      }, opts);
      const env = Object.assign({}, opts.env);
      const path2 = pathKey({ env });
      opts.path = env[path2];
      env[path2] = module.exports(opts);
      return env;
    };
  }
});

// ../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isStream = module.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// ../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/buffer-stream.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var PassThrough = __require("stream").PassThrough;
    module.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream = new PassThrough({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    };
  }
});

// ../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var bufferStream = require_buffer_stream();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream;
      let clean;
      const p = new Promise((resolve, reject) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream.getBufferedValue();
          }
          reject(err);
        };
        stream = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream);
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            reject(new Error("maxBuffer exceeded"));
          }
        });
        stream.once("error", error);
        stream.on("end", resolve);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream.getBufferedValue());
    }
    module.exports = getStream;
    module.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, { encoding: "buffer" }));
    module.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, { array: true }));
  }
});

// ../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/errname.js
var require_errname = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/errname.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var uv;
    try {
      uv = process.binding("uv");
      if (typeof uv.errname !== "function") {
        throw new TypeError("uv.errname is not a function");
      }
    } catch (err) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
      uv = null;
    }
    function errname(uv2, code) {
      if (uv2) {
        return uv2.errname(code);
      }
      if (!(code < 0)) {
        throw new Error("err >= 0");
      }
      return `Unknown system error ${code}`;
    }
    module.exports = (code) => errname(uv, code);
    module.exports.__test__ = errname;
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/stdio.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var alias = ["stdin", "stdout", "stderr"];
    var hasAlias = (opts) => alias.some((x) => Boolean(opts[x]));
    module.exports = (opts) => {
      if (!opts) {
        return null;
      }
      if (opts.stdio && hasAlias(opts)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
      }
      if (typeof opts.stdio === "string") {
        return opts.stdio;
      }
      const stdio = opts.stdio || [];
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const result = [];
      const len = Math.max(stdio.length, alias.length);
      for (let i = 0; i < len; i++) {
        let value = null;
        if (stdio[i] !== void 0) {
          value = stdio[i];
        } else if (opts[alias[i]] !== void 0) {
          value = opts[alias[i]];
        }
        result[i] = value;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/index.js
var require_execa = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path");
    var childProcess = __require("child_process");
    var util = __require("util");
    var crossSpawn = require_cross_spawn();
    var stripEof = require_strip_eof();
    var npmRunPath = require_npm_run_path();
    var isStream = require_is_stream();
    var _getStream = require_get_stream();
    var pFinally = require_p_finally();
    var onExit = require_signal_exit();
    var errname = require_errname();
    var stdio = require_stdio();
    var TEN_MEGABYTES = 1e3 * 1e3 * 10;
    function handleArgs(cmd, args, opts) {
      let parsed;
      opts = Object.assign({
        extendEnv: true,
        env: {}
      }, opts);
      if (opts.extendEnv) {
        opts.env = Object.assign({}, process.env, opts.env);
      }
      if (opts.__winShell === true) {
        delete opts.__winShell;
        parsed = {
          command: cmd,
          args,
          options: opts,
          file: cmd,
          original: cmd
        };
      } else {
        parsed = crossSpawn._parse(cmd, args, opts);
      }
      opts = Object.assign({
        maxBuffer: TEN_MEGABYTES,
        stripEof: true,
        preferLocal: true,
        localDir: parsed.options.cwd || process.cwd(),
        encoding: "utf8",
        reject: true,
        cleanup: true
      }, parsed.options);
      opts.stdio = stdio(opts);
      if (opts.preferLocal) {
        opts.env = npmRunPath.env(Object.assign({}, opts, { cwd: opts.localDir }));
      }
      if (opts.detached) {
        opts.cleanup = false;
      }
      if (process.platform === "win32" && path.basename(parsed.command) === "cmd.exe") {
        parsed.args.unshift("/q");
      }
      return {
        cmd: parsed.command,
        args: parsed.args,
        opts,
        parsed
      };
    }
    function handleInput(spawned, opts) {
      const input = opts.input;
      if (input === null || input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    }
    function handleOutput(opts, val) {
      if (val && opts.stripEof) {
        val = stripEof(val);
      }
      return val;
    }
    function handleShell(fn, cmd, opts) {
      let file = "/bin/sh";
      let args = ["-c", cmd];
      opts = Object.assign({}, opts);
      if (process.platform === "win32") {
        opts.__winShell = true;
        file = process.env.comspec || "cmd.exe";
        args = ["/s", "/c", `"${cmd}"`];
        opts.windowsVerbatimArguments = true;
      }
      if (opts.shell) {
        file = opts.shell;
        delete opts.shell;
      }
      return fn(file, args, opts);
    }
    function getStream(process2, stream, encoding, maxBuffer) {
      if (!process2[stream]) {
        return null;
      }
      let ret;
      if (encoding) {
        ret = _getStream(process2[stream], {
          encoding,
          maxBuffer
        });
      } else {
        ret = _getStream.buffer(process2[stream], { maxBuffer });
      }
      return ret.catch((err) => {
        err.stream = stream;
        err.message = `${stream} ${err.message}`;
        throw err;
      });
    }
    function makeError(result, options) {
      const stdout = result.stdout;
      const stderr = result.stderr;
      let err = result.error;
      const code = result.code;
      const signal = result.signal;
      const parsed = options.parsed;
      const joinedCmd = options.joinedCmd;
      const timedOut = options.timedOut || false;
      if (!err) {
        let output = "";
        if (Array.isArray(parsed.opts.stdio)) {
          if (parsed.opts.stdio[2] !== "inherit") {
            output += output.length > 0 ? stderr : `
${stderr}`;
          }
          if (parsed.opts.stdio[1] !== "inherit") {
            output += `
${stdout}`;
          }
        } else if (parsed.opts.stdio !== "inherit") {
          output = `
${stderr}${stdout}`;
        }
        err = new Error(`Command failed: ${joinedCmd}${output}`);
        err.code = code < 0 ? errname(code) : code;
      }
      err.stdout = stdout;
      err.stderr = stderr;
      err.failed = true;
      err.signal = signal || null;
      err.cmd = joinedCmd;
      err.timedOut = timedOut;
      return err;
    }
    function joinCmd(cmd, args) {
      let joinedCmd = cmd;
      if (Array.isArray(args) && args.length > 0) {
        joinedCmd += " " + args.join(" ");
      }
      return joinedCmd;
    }
    module.exports = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const encoding = parsed.opts.encoding;
      const maxBuffer = parsed.opts.maxBuffer;
      const joinedCmd = joinCmd(cmd, args);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
      } catch (err) {
        return Promise.reject(err);
      }
      let removeExitHandler;
      if (parsed.opts.cleanup) {
        removeExitHandler = onExit(() => {
          spawned.kill();
        });
      }
      let timeoutId = null;
      let timedOut = false;
      const cleanupTimeout = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      if (parsed.opts.timeout > 0) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          timedOut = true;
          spawned.kill(parsed.opts.killSignal);
        }, parsed.opts.timeout);
      }
      const processDone = new Promise((resolve) => {
        spawned.on("exit", (code, signal) => {
          cleanupTimeout();
          resolve({ code, signal });
        });
        spawned.on("error", (err) => {
          cleanupTimeout();
          resolve({ error: err });
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (err) => {
            cleanupTimeout();
            resolve({ error: err });
          });
        }
      });
      function destroy() {
        if (spawned.stdout) {
          spawned.stdout.destroy();
        }
        if (spawned.stderr) {
          spawned.stderr.destroy();
        }
      }
      const handlePromise = () => pFinally(Promise.all([
        processDone,
        getStream(spawned, "stdout", encoding, maxBuffer),
        getStream(spawned, "stderr", encoding, maxBuffer)
      ]).then((arr) => {
        const result = arr[0];
        result.stdout = arr[1];
        result.stderr = arr[2];
        if (removeExitHandler) {
          removeExitHandler();
        }
        if (result.error || result.code !== 0 || result.signal !== null) {
          const err = makeError(result, {
            joinedCmd,
            parsed,
            timedOut
          });
          err.killed = err.killed || spawned.killed;
          if (!parsed.opts.reject) {
            return err;
          }
          throw err;
        }
        return {
          stdout: handleOutput(parsed.opts, result.stdout),
          stderr: handleOutput(parsed.opts, result.stderr),
          code: 0,
          failed: false,
          killed: false,
          signal: null,
          cmd: joinedCmd,
          timedOut: false
        };
      }), destroy);
      crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
      handleInput(spawned, parsed.opts);
      spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
      spawned.catch = (onrejected) => handlePromise().catch(onrejected);
      return spawned;
    };
    module.exports.stdout = function() {
      return module.exports.apply(null, arguments).then((x) => x.stdout);
    };
    module.exports.stderr = function() {
      return module.exports.apply(null, arguments).then((x) => x.stderr);
    };
    module.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);
    module.exports.sync = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const joinedCmd = joinCmd(cmd, args);
      if (isStream(parsed.opts.input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
      result.code = result.status;
      if (result.error || result.status !== 0 || result.signal !== null) {
        const err = makeError(result, {
          joinedCmd,
          parsed
        });
        if (!parsed.opts.reject) {
          return err;
        }
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    };
    module.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);
    module.exports.spawn = util.deprecate(module.exports, "execa.spawn() is deprecated. Use execa() instead.");
  }
});

// ../../node_modules/.pnpm/pid-from-port@1.1.3/node_modules/pid-from-port/index.js
var require_pid_from_port = __commonJS({
  "../../node_modules/.pnpm/pid-from-port@1.1.3/node_modules/pid-from-port/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var execa = require_execa();
    var macos = () => execa.stdout("netstat", ["-anv", "-p", "tcp"]).then((data) => Promise.all([data, execa.stdout("netstat", ["-anv", "-p", "udp"])])).then((data) => data.join("\n"));
    var linux = () => execa.stdout("ss", ["-tunlp"]);
    var win32 = () => execa.stdout("netstat", ["-ano"]);
    var getListFn = process.platform === "darwin" ? macos : process.platform === "linux" ? linux : win32;
    var cols = process.platform === "darwin" ? [3, 8] : process.platform === "linux" ? [4, 6] : [1, 4];
    var isProtocol = (x) => /^\s*(tcp|udp)/i.test(x);
    var parsePid = (input) => {
      if (typeof input !== "string") {
        return null;
      }
      const match = input.match(/(?:^|",|",pid=)(\d+)/);
      return match ? parseInt(match[1], 10) : null;
    };
    var getPort = (input, list) => {
      const regex = new RegExp(`[.:]${input}$`);
      const port = list.find((x) => regex.test(x[cols[0]]));
      if (!port) {
        throw new Error(`Couldn't find a process with port \`${input}\``);
      }
      return parsePid(port[cols[1]]);
    };
    var getList = () => getListFn().then(
      (list) => list.split("\n").reduce((result, x) => {
        if (isProtocol(x)) {
          result.push(x.match(/\S+/g) || []);
        }
        return result;
      }, [])
    );
    module.exports = (input) => {
      if (typeof input !== "number") {
        return Promise.reject(new TypeError(`Expected a number, got ${typeof input}`));
      }
      return getList().then((list) => getPort(input, list));
    };
    module.exports.all = (input) => {
      if (!Array.isArray(input)) {
        return Promise.reject(new TypeError(`Expected an array, got ${typeof input}`));
      }
      return getList().then((list) => Promise.all(input.map((x) => [x, getPort(x, list)]))).then((list) => new Map(list));
    };
    module.exports.list = () => getList().then((list) => {
      const ret = /* @__PURE__ */ new Map();
      for (const x of list) {
        const match = x[cols[0]].match(/[^]*[.:](\d+)$/);
        if (match) {
          ret.set(parseInt(match[1], 10), parsePid(x[cols[1]]));
        }
      }
      return ret;
    });
  }
});

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/killer.js
var require_killer = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/killer.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Killer = void 0;
    var child_process_1 = __require("child_process");
    var os_1 = __require("os");
    var pidFromPort = require_pid_from_port();
    var Killer = class {
      constructor(ports) {
        this.ports = ports;
      }
      kill(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const killFunc = os_1.platform() === "win32" ? this.win32Kill : this.unixKill;
          const promises = this.ports.map((port) => killFunc(port, options.signal));
          return Promise.all(promises);
        });
      }
      win32Kill(port, signal) {
        return __awaiter(this, void 0, void 0, function* () {
          const pid = yield pidFromPort(port).catch((error) => console.error("Failed to get pid of port", port, error));
          if (!pid) {
            return;
          }
          return new Promise((resolve, reject) => {
            const taskkill = child_process_1.spawn("TASKKILL", ["/f", "/t", "/pid", pid.toString()]);
            taskkill.stdout.on("data", (data) => console.log(data.toString()));
            taskkill.stderr.on("data", (data) => console.error(data.toString()));
            taskkill.on("close", (code, signal2) => {
              if (code !== 0) {
                return reject(`taskkill process exited with code ${code} and signal ${signal2}`);
              }
              resolve(void 0);
            });
            taskkill.on("error", (err) => reject(err));
          });
        });
      }
      unixKill(port, signal) {
        return __awaiter(this, void 0, void 0, function* () {
          const killCommand = {
            SIGKILL: "-9",
            SIGTERM: "-15"
          }[signal];
          return new Promise((resolve, reject) => {
            const lsof = child_process_1.spawn("lsof", ["-i", `tcp:${port}`]);
            const grep = child_process_1.spawn("grep", ["LISTEN"]);
            const awk = child_process_1.spawn("awk", ["{print $2}"]);
            const xargs = child_process_1.spawn("xargs", ["kill", killCommand]);
            lsof.stdout.pipe(grep.stdin);
            lsof.stderr.on("data", logStderrData("lsof"));
            grep.stdout.pipe(awk.stdin);
            grep.stderr.on("data", logStderrData("grep"));
            awk.stdout.pipe(xargs.stdin);
            awk.stderr.on("data", logStderrData("awk"));
            xargs.stdout.pipe(process.stdin);
            xargs.stderr.on("data", logStderrData("xargs"));
            xargs.on("close", (code) => {
              if (code !== 0) {
                return reject();
              }
              resolve(void 0);
            });
            function logStderrData(command) {
              return (data) => console.error(`${command} - ${data.toString()}`);
            }
          });
        });
      }
    };
    exports.Killer = Killer;
  }
});

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/index.js"(exports) {
    init_cjs_shims();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.killPortProcess = void 0;
    var helpers_1 = require_helpers();
    var killer_1 = require_killer();
    function killPortProcess(inputPorts, inputOptions = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (helpers_1.isNullOrUndefined(inputPorts)) {
          throw new Error("No ports found in input");
        }
        const options = helpers_1.mergeOptions(inputOptions);
        const toNumber = (value) => Number(value);
        const ports = helpers_1.arrayifyInput(inputPorts).map(toNumber);
        const killer = new killer_1.Killer(ports);
        yield killer.kill({
          signal: options.signal
        });
      });
    }
    exports.killPortProcess = killPortProcess;
  }
});
export default require_lib();
//# sourceMappingURL=lib-MUDJYT6A.js.map
