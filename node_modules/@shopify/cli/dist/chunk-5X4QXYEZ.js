import {
  require_toml
} from "./chunk-EARPFFS7.js";
import {
  errorHandler,
  registerCleanBugsnagErrorsFromWithinPlugins
} from "./chunk-JKYNFUD3.js";
import {
  hashString
} from "./chunk-ADESJ2KG.js";
import {
  AbortError,
  addPublicMetadata,
  addSensitiveMetadata,
  findPathUp,
  isDevelopment,
  isTruthy,
  outputContent,
  outputInfo,
  outputToken,
  readFile,
  renderInfo,
  renderWarning,
  terminalSupportsRawMode,
  underscore
} from "./chunk-WAEWSGBK.js";
import {
  require_lib
} from "./chunk-GEN4RXTD.js";
import {
  cwd
} from "./chunk-UNPXLODI.js";
import {
  __toESM,
  init_cjs_shims
} from "./chunk-ZPL24Y2D.js";

// ../cli-kit/src/public/node/base-command.ts
init_cjs_shims();

// ../cli-kit/src/public/node/environments.ts
init_cjs_shims();

// ../cli-kit/src/public/node/toml.ts
init_cjs_shims();
var toml = __toESM(require_toml(), 1);
function decodeToml(input) {
  const normalizedInput = input.replace(/\r\n$/g, "\n");
  return toml.parse(normalizedInput);
}
function encodeToml(content) {
  const tomlSafeContent = content;
  return toml.stringify(tomlSafeContent);
}

// ../cli-kit/src/public/node/environments.ts
async function loadEnvironment(environmentName, fileName, options) {
  const basePath = options?.from && options?.from !== "." ? options.from : cwd();
  const filePath = await findPathUp(fileName, {
    cwd: basePath,
    type: "file"
  });
  if (!filePath) {
    renderWarning({ body: "Environment file not found." });
    return void 0;
  }
  const environmentsJson = decodeToml(await readFile(filePath));
  const environments = environmentsJson.environments;
  if (!environments) {
    renderWarning({
      body: ["No environments found in", { command: filePath }, { char: "." }]
    });
    return void 0;
  }
  const environment = environments[environmentName];
  if (!environment)
    renderWarning({
      body: ["Environment", { command: environmentName }, "not found."]
    });
  await addSensitiveMetadata(() => ({
    environmentFlags: JSON.stringify(environment)
  }));
  return environment;
}

// ../cli-kit/src/public/node/base-command.ts
var import_core = __toESM(require_lib(), 1);
var BaseCommand = class extends import_core.Command {
  // Replace markdown links to plain text like: "link label" (url)
  static descriptionWithoutMarkdown() {
    return (this.descriptionWithMarkdown ?? "").replace(/(\[)(.*?)(])(\()(.*?)(\))/gm, '"$2" ($5)');
  }
  static analyticsNameOverride() {
    return void 0;
  }
  static analyticsStopCommand() {
    return void 0;
  }
  async catch(error) {
    error.skipOclifErrorHandling = true;
    await errorHandler(error, this.config);
    return import_core.Errors.handle(error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async init() {
    this.exitWithTimestampWhenEnvVariablePresent();
    if (!isDevelopment()) {
      await registerCleanBugsnagErrorsFromWithinPlugins(this.config);
    }
    this.showNpmFlagWarning();
    return super.init();
  }
  // NPM creates an environment variable for every flag passed to a script.
  // This function checks for the presence of any of the available CLI flags
  // and warns the user to use the `--` separator.
  showNpmFlagWarning() {
    const commandVariables = this.constructor;
    const commandFlags = Object.keys(commandVariables.flags || {});
    const possibleNpmEnvVars = commandFlags.map((key) => `npm_config_${underscore(key).replace(/^no_/, "")}`);
    if (possibleNpmEnvVars.some((flag) => process.env[flag] !== void 0)) {
      renderWarning({
        body: [
          "NPM scripts require an extra",
          { command: "--" },
          "separator to pass the flags. Example:",
          { command: "npm run dev -- --reset" }
        ]
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  exitWithTimestampWhenEnvVariablePresent() {
    if (isTruthy(process.env.SHOPIFY_CLI_ENV_STARTUP_PERFORMANCE_RUN)) {
      outputInfo(`
      SHOPIFY_CLI_TIMESTAMP_START
      { "timestamp": ${Date.now()} }
      SHOPIFY_CLI_TIMESTAMP_END
      `);
      process.exit(0);
    }
  }
  async parse(options, argv) {
    let result = await super.parse(options, argv);
    result = await this.resultWithEnvironment(result, options, argv);
    await addFromParsedFlags(result.flags);
    return { ...result, ...{ argv: result.argv } };
  }
  environmentsFilename() {
    return void 0;
  }
  failMissingNonTTYFlags(flags, requiredFlags) {
    if (terminalSupportsRawMode())
      return;
    requiredFlags.forEach((name) => {
      if (!(name in flags)) {
        throw new AbortError(
          outputContent`Flag not specified:

${outputToken.cyan(name)}

This flag is required in non-interactive terminal environments, such as a CI environment, or when piping input from another process.`,
          "To resolve this, specify the option in the command, or run the command in an interactive environment such as your local terminal."
        );
      }
    });
  }
  async resultWithEnvironment(originalResult, options, argv) {
    const flags = originalResult.flags;
    const environmentsFileName = this.environmentsFilename();
    if (!flags.environment || !environmentsFileName)
      return originalResult;
    const environment = await loadEnvironment(flags.environment, environmentsFileName, { from: flags.path });
    if (!environment)
      return originalResult;
    const noDefaultsResult = await super.parse(noDefaultsOptions(options), argv);
    const result = await super.parse(options, [
      // Need to specify argv default because we're merging with argsFromEnvironment.
      ...argv || this.argv,
      ...argsFromEnvironment(environment, options, noDefaultsResult)
    ]);
    reportEnvironmentApplication(
      noDefaultsResult.flags,
      result.flags,
      flags.environment,
      environment
    );
    return result;
  }
};
async function addFromParsedFlags(flags) {
  await addPublicMetadata(() => ({
    cmd_all_verbose: flags.verbose,
    cmd_all_path_override: flags.path !== void 0,
    cmd_all_path_override_hash: flags.path === void 0 ? void 0 : hashString(flags.path)
  }));
}
function reportEnvironmentApplication(noDefaultsFlags, flagsWithEnvironments, environmentName, environment) {
  const changes = {};
  for (const [name, value] of Object.entries(flagsWithEnvironments)) {
    const userSpecifiedThisFlag = Object.prototype.hasOwnProperty.call(noDefaultsFlags, name);
    const environmentContainsFlag = Object.prototype.hasOwnProperty.call(environment, name);
    if (!userSpecifiedThisFlag && environmentContainsFlag) {
      const valueToReport = name === "password" ? `********${value.substr(-4)}` : value;
      changes[name] = valueToReport;
    }
  }
  if (Object.keys(changes).length === 0)
    return;
  const items = Object.entries(changes).map(([name, value]) => `${name}: ${value}`);
  renderInfo({
    headline: ["Using applicable flags from", { userInput: environmentName }, "environment:"],
    body: [{ list: { items } }]
  });
}
function noDefaultsOptions(options) {
  if (!options?.flags)
    return options;
  return {
    ...options,
    flags: Object.fromEntries(
      Object.entries(options.flags).map(([label, settings]) => {
        const copiedSettings = { ...settings };
        delete copiedSettings.default;
        return [label, copiedSettings];
      })
    )
  };
}
function argsFromEnvironment(environment, options, noDefaultsResult) {
  const args = [];
  for (const [label, value] of Object.entries(environment)) {
    const flagIsRelevantToCommand = options?.flags && Object.prototype.hasOwnProperty.call(options.flags, label);
    const userSpecifiedThisFlag = noDefaultsResult.flags && Object.prototype.hasOwnProperty.call(noDefaultsResult.flags, label);
    if (flagIsRelevantToCommand && !userSpecifiedThisFlag) {
      if (typeof value === "boolean") {
        if (value === true) {
          args.push(`--${label}`);
        } else {
          throw new AbortError(
            outputContent`Environments can only specify true for boolean flags. Attempted to set ${outputToken.yellow(
              label
            )} to false.`
          );
        }
      } else if (Array.isArray(value)) {
        value.forEach((element) => args.push(`--${label}`, `${element}`));
      } else {
        args.push(`--${label}`, `${value}`);
      }
    }
  }
  return args;
}
var base_command_default = BaseCommand;

export {
  decodeToml,
  encodeToml,
  base_command_default
};
//# sourceMappingURL=chunk-5X4QXYEZ.js.map
