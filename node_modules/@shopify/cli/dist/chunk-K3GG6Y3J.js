import {
  ClientError,
  fetch,
  require_form_data,
  require_src,
  require_src2,
  require_src3,
  require_src4,
  require_src5,
  require_src6
} from "./chunk-LC6MEJT3.js";
import {
  getEnvironmentData,
  getSensitiveEnvironmentData
} from "./chunk-ADESJ2KG.js";
import {
  platformAndArch
} from "./chunk-66NABVCG.js";
import {
  CLI_KIT_VERSION
} from "./chunk-B62HZLMM.js";
import {
  require_semver
} from "./chunk-PRJ3U7MR.js";
import {
  AbortError,
  AbortSilentError,
  alwaysLogAnalytics,
  alwaysLogMetrics,
  analyticsDisabled,
  appendFile,
  captureOutput,
  exec,
  fileExists,
  findPathUp,
  firstPartyDev,
  getAllPublicMetadata,
  getAllSensitiveMetadata,
  getArrayContainsDuplicates,
  getArrayRejectingUndefined,
  import_ts_error,
  isShopify,
  isSpinEnvironment,
  isTruthy,
  isUnitTest,
  mkdir,
  opentelemetryDomain,
  outputContent,
  outputDebug,
  outputToken,
  readFile,
  runWithTimer,
  serviceEnvironment,
  spinFqdn,
  touchFile,
  useEmbeddedThemeCLI
} from "./chunk-WAEWSGBK.js";
import {
  envPaths,
  environmentVariables,
  pathConstants,
  systemEnvironmentVariables
} from "./chunk-WADS2TV5.js";
import {
  cwd,
  dirname,
  joinPath
} from "./chunk-UNPXLODI.js";
import {
  __toESM,
  init_cjs_shims
} from "./chunk-ZPL24Y2D.js";

// ../cli-kit/src/public/node/plugins.ts
init_cjs_shims();
async function fanoutHooks(config, event, options, timeout) {
  const res = await config.runHook(event, options, timeout);
  return Object.fromEntries(res.successes.map(({ result, plugin }) => [plugin.name, result]));
}
async function getListOfTunnelPlugins(config) {
  const hooks = await fanoutHooks(config, "tunnel_provider", {});
  const names = getArrayRejectingUndefined(Object.values(hooks).map((key) => key?.name));
  if (getArrayContainsDuplicates(names))
    return { plugins: names, error: "multiple-plugins-for-provider" };
  return { plugins: names };
}

// ../cli-kit/src/public/node/analytics.ts
init_cjs_shims();

// ../cli-kit/src/public/node/ruby.ts
init_cjs_shims();

// ../cli-kit/src/public/node/environment.ts
init_cjs_shims();
function getEnvironmentVariables() {
  return process.env;
}
function getPartnersToken() {
  return getEnvironmentVariables()[environmentVariables.partnersToken];
}
function getOrganization() {
  return getEnvironmentVariables()[environmentVariables.organization];
}
function getBackendPort() {
  const backendPort = getEnvironmentVariables()[systemEnvironmentVariables.backendPort];
  if (backendPort && !isNaN(Number(backendPort))) {
    return Number(backendPort);
  }
  return void 0;
}
function getIdentityTokenInformation() {
  const identityToken = getEnvironmentVariables()[environmentVariables.identityToken];
  const refreshToken = getEnvironmentVariables()[environmentVariables.refreshToken];
  if (!identityToken || !refreshToken)
    return void 0;
  return {
    accessToken: identityToken,
    refreshToken
  };
}

// ../cli-kit/src/public/node/ruby.ts
var import_semver = __toESM(require_semver(), 1);
import { fileURLToPath } from "url";
var RubyCLIVersion = "2.35.0";
var MinBundlerVersion = "2.3.11";
var MinRubyVersion = "2.7.5";
var MinWdmWindowsVersion = "0.1.0";
async function execCLI2(args, options = {}) {
  const currentEnv = getEnvironmentVariables();
  const embedded = useEmbeddedThemeCLI(currentEnv) && !currentEnv.SHOPIFY_CLI_2_0_DIRECTORY;
  await installCLIDependencies(options.stdout ?? process.stdout, embedded);
  const env = {
    ...currentEnv,
    SHOPIFY_CLI_STOREFRONT_RENDERER_AUTH_TOKEN: options.storefrontToken,
    SHOPIFY_CLI_ADMIN_AUTH_TOKEN: options.adminToken,
    SHOPIFY_SHOP: options.store,
    SHOPIFY_CLI_AUTH_TOKEN: options.token,
    SHOPIFY_CLI_RUN_AS_SUBPROCESS: "true",
    SHOPIFY_CLI_RUBY_BIN: rubyExecutable(),
    // Bundler uses this Gemfile to understand which gems are available in the
    // environment. We use this to specify our own Gemfile for CLI2, which exists
    // outside the user's project directory.
    BUNDLE_GEMFILE: joinPath(await shopifyCLIDirectory(embedded), "Gemfile"),
    ...await getSpinEnvironmentVariables(),
    SHOPIFY_CLI_1P_DEV: firstPartyDev() ? "1" : "0",
    SHOPIFY_CLI_VERSION: CLI_KIT_VERSION
  };
  try {
    const shopifyExecutable = embedded ? [rubyExecutable(), await embeddedCLIExecutable()] : ["shopify"];
    await runBundler(["exec", ...shopifyExecutable, ...args], {
      ...options.stdout === void 0 && { stdio: "inherit" },
      cwd: options.directory ?? cwd(),
      env,
      ...options.stdout !== void 0 && { stdout: options.stdout, stderr: options.stderr },
      signal: options.signal
    });
  } catch (error) {
    throw new AbortSilentError();
  }
}
async function installCLIDependencies(stdout, embedded = false) {
  const localCLI = await shopifyCLIDirectory(embedded);
  const exists = await fileExists(localCLI);
  if (!exists)
    stdout.write("Installing theme dependencies...");
  const usingLocalCLI2 = embedded || isTruthy(getEnvironmentVariables().SHOPIFY_CLI_2_0_DIRECTORY);
  await validateRubyEnv();
  if (usingLocalCLI2) {
    await bundleInstallLocalShopifyCLI(localCLI);
  } else {
    await createShopifyCLIWorkingDirectory();
    await createShopifyCLIGemfile();
    await bundleInstallShopifyCLI();
  }
  if (!exists)
    stdout.write("Installed theme dependencies!");
}
async function validateRubyEnv() {
  await validateRuby();
  await validateBundler();
}
async function validateRuby() {
  let version2;
  try {
    const stdout = await captureOutput(rubyExecutable(), ["-v"]);
    version2 = (0, import_semver.coerce)(stdout);
  } catch {
    throw new AbortError(
      "Ruby environment not found",
      `Make sure you have Ruby installed on your system. ${outputContent`${outputToken.link("Documentation.", "https://www.ruby-lang.org/en/documentation/installation/")}`.value}`
    );
  }
  const isValid = version2?.compare(MinRubyVersion);
  if (isValid === -1 || isValid === void 0) {
    throw new AbortError(
      `Ruby version ${outputContent`${outputToken.yellow(version2?.raw ?? "unknown")}`.value} is not supported`,
      `Make sure you have at least Ruby ${outputContent`${outputToken.yellow(MinRubyVersion)}`.value} installed on your system. ${outputContent`${outputToken.link("Documentation.", "https://www.ruby-lang.org/en/documentation/installation/")}`.value}`
    );
  }
}
async function validateBundler() {
  let version2;
  try {
    const stdout = await captureOutput(bundleExecutable(), ["-v"], { env: { BUNDLE_USER_HOME: bundleUserHome() } });
    version2 = (0, import_semver.coerce)(stdout);
  } catch {
    throw new AbortError(
      "Bundler not found",
      `To install the latest version of Bundler, run ${outputContent`${outputToken.genericShellCommand(`${gemExecutable()} install bundler`)}`.value}`
    );
  }
  const isValid = version2?.compare(MinBundlerVersion);
  if (isValid === -1 || isValid === void 0) {
    throw new AbortError(
      `Bundler version ${outputContent`${outputToken.yellow(version2?.raw ?? "unknown")}`.value} is not supported`,
      `To update to the latest version of Bundler, run ${outputContent`${outputToken.genericShellCommand(`${gemExecutable()} install bundler`)}`.value}`
    );
  }
}
async function createShopifyCLIWorkingDirectory() {
  return mkdir(await shopifyCLIDirectory());
}
async function createShopifyCLIGemfile() {
  const directory = await shopifyCLIDirectory();
  const gemfileContent = getBaseGemfileContent().concat(getWindowsDependencies());
  await addContentToGemfile(directory, gemfileContent);
}
async function bundleInstallLocalShopifyCLI(directory) {
  await addContentToGemfile(directory, getWindowsDependencies());
  await shopifyBundleInstall(directory);
}
function getBaseGemfileContent() {
  return ["source 'https://rubygems.org'", `gem 'shopify-cli', '${RubyCLIVersion}'`];
}
function getWindowsDependencies() {
  if (platformAndArch().platform === "windows") {
    return [`gem 'wdm', '>= ${MinWdmWindowsVersion}'`];
  }
  return [];
}
async function addContentToGemfile(gemfileDirectory, content) {
  const gemfilePath = joinPath(gemfileDirectory, "Gemfile");
  if (!await fileExists(gemfilePath))
    await touchFile(gemfilePath);
  const gemContent = await readFile(gemfilePath, { encoding: "utf8" });
  const contentNoExisting = content.filter((line) => !gemContent.includes(line)).join("\n");
  if (contentNoExisting)
    await appendFile(gemfilePath, contentNoExisting.concat("\n"));
}
async function bundleInstallShopifyCLI() {
  await shopifyBundleInstall(await shopifyCLIDirectory());
}
async function shopifyCLIDirectory(embedded = false) {
  const embeddedDirectory = await findPathUp("assets/cli-ruby", {
    type: "directory",
    cwd: dirname(fileURLToPath(import.meta.url))
  });
  const bundledDirectory = joinPath(pathConstants.directories.cache.vendor.path(), "ruby-cli", RubyCLIVersion);
  return embedded ? embeddedDirectory : getEnvironmentVariables().SHOPIFY_CLI_2_0_DIRECTORY ?? bundledDirectory;
}
async function version() {
  const parseOutput = (version2) => version2.match(/ruby (\d+\.\d+\.\d+)/)?.[1];
  return captureOutput(rubyExecutable(), ["-v"]).then(parseOutput).catch(() => void 0);
}
function getRubyBinDir() {
  return getEnvironmentVariables().SHOPIFY_RUBY_BINDIR;
}
function rubyExecutable() {
  const rubyBinDir = getRubyBinDir();
  return rubyBinDir ? joinPath(rubyBinDir, "ruby") : "ruby";
}
function bundleExecutable() {
  const rubyBinDir = getRubyBinDir();
  return rubyBinDir ? joinPath(rubyBinDir, "bundle") : "bundle";
}
function gemExecutable() {
  const rubyBinDir = getRubyBinDir();
  return rubyBinDir ? joinPath(rubyBinDir, "gem") : "gem";
}
async function embeddedCLIExecutable() {
  const cliDirectory = await shopifyCLIDirectory(true);
  return joinPath(cliDirectory, "bin", "shopify");
}
async function getSpinEnvironmentVariables() {
  if (!isSpinEnvironment())
    return {};
  return {
    SPIN_FQDN: await spinFqdn(),
    SPIN: "1"
  };
}
async function shopifyBundleInstall(directory) {
  return runWithTimer("cmd_all_timing_network_ms")(async () => {
    await runBundler(["install"], { cwd: directory });
  });
}
function bundleUserHome() {
  if (platformAndArch().platform === "windows" && process.env.PUBLIC) {
    return joinPath(process.env.PUBLIC, "AppData", "Local", "shopify-bundler-nodejs", "Cache");
  } else {
    return void 0;
  }
}
async function runBundler(args, options) {
  return exec(bundleExecutable(), args, {
    ...options,
    env: {
      ...options.env,
      BUNDLE_USER_HOME: bundleUserHome(),
      BUNDLE_WITHOUT: "development:test",
      BUNDLE_PATH: envPaths("shopify-gems").cache
    }
  });
}

// ../cli-kit/src/public/node/monorail.ts
init_cjs_shims();

// ../cli-kit/src/public/node/http.ts
init_cjs_shims();

// ../cli-kit/src/private/node/api/headers.ts
init_cjs_shims();
import https from "https";
var RequestClientError = class extends import_ts_error.ExtendableError {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
};
var GraphQLClientError = class extends RequestClientError {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(message, statusCode, errors) {
    super(message, statusCode);
    this.errors = errors;
    this.stack = void 0;
  }
};
function sanitizedHeadersOutput(headers) {
  const sanitized = {};
  const keywords = ["token", "authorization", "subject_token"];
  Object.keys(headers).forEach((header) => {
    if (keywords.find((keyword) => header.toLocaleLowerCase().includes(keyword)) === void 0) {
      sanitized[header] = headers[header];
    }
  });
  return Object.keys(sanitized).map((header) => {
    return ` - ${header}: ${sanitized[header]}`;
  }).join("\n");
}
function buildHeaders(token) {
  const userAgent = `Shopify CLI; v=${CLI_KIT_VERSION}`;
  const headers = {
    "User-Agent": userAgent,
    "Keep-Alive": "timeout=30",
    // 'Sec-CH-UA': secCHUA, This header requires the Git sha.
    "Sec-CH-UA-PLATFORM": process.platform,
    "Content-Type": "application/json",
    ...firstPartyDev() && { "X-Shopify-Cli-Employee": "1" }
  };
  if (token) {
    const authString = token.match(/^shp(at|ua|ca)/) ? token : `Bearer ${token}`;
    headers["authorization"] = authString;
    headers["X-Shopify-Access-Token"] = authString;
  }
  return headers;
}
async function httpsAgent() {
  return new https.Agent({
    rejectUnauthorized: await shouldRejectUnauthorizedRequests(),
    keepAlive: true
  });
}
async function shouldRejectUnauthorizedRequests() {
  return await serviceEnvironment() !== "spin" /* Spin */;
}

// ../cli-kit/src/private/node/api/urls.ts
init_cjs_shims();
function sanitizeURL(url2) {
  const parsedUrl = new URL(url2);
  if (parsedUrl.searchParams.has("subject_token")) {
    parsedUrl.searchParams.set("subject_token", "****");
  }
  if (parsedUrl.searchParams.has("token")) {
    parsedUrl.searchParams.set("token", "****");
  }
  return parsedUrl.toString();
}

// ../cli-kit/src/private/node/api.ts
init_cjs_shims();
import { performance } from "perf_hooks";
var allAPIs = ["admin", "storefront-renderer", "partners", "business-platform", "app-management"];
var interestingResponseHeaders = /* @__PURE__ */ new Set(["cache-control", "content-type", "etag", "x-request-id"]);
async function debugLogResponseInfo({ request, url: url2 }, errorHandler) {
  const t0 = performance.now();
  const responseHeaders = {};
  let response = {};
  try {
    response = await request;
    response.headers.forEach((value, key) => {
      if (interestingResponseHeaders.has(key))
        responseHeaders[key] = value;
    });
  } catch (err) {
    if (err instanceof ClientError) {
      if (err.response?.headers) {
        for (const [key, value] of err.response?.headers) {
          if (interestingResponseHeaders.has(key))
            responseHeaders[key] = value;
        }
      }
    }
    if (errorHandler) {
      throw errorHandler(err, responseHeaders["x-request-id"]);
    } else {
      throw err;
    }
  } finally {
    const t1 = performance.now();
    outputDebug(`Request to ${sanitizeURL(url2)} completed in ${Math.round(t1 - t0)} ms
With response headers:
${sanitizedHeadersOutput(responseHeaders)}
    `);
  }
  return response;
}

// ../cli-kit/src/public/node/http.ts
var import_form_data = __toESM(require_form_data(), 1);
function formData() {
  return new import_form_data.default();
}
async function fetch2(url2, init) {
  return runWithTimer("cmd_all_timing_network_ms")(
    () => debugLogResponseInfo({ url: url2.toString(), request: fetch(url2, init) })
  );
}
async function shopifyFetch(url2, init) {
  const sanitizedUrl = sanitizeURL(url2.toString());
  const options = {
    ...init ?? {},
    headers: {
      ...await buildHeaders(),
      ...init?.headers ?? {}
    }
  };
  outputDebug(outputContent`Sending ${options.method ?? "GET"} request to URL ${sanitizedUrl}
With request headers:
${sanitizedHeadersOutput(options?.headers ?? {})}
`);
  return runWithTimer("cmd_all_timing_network_ms")(async () => {
    return debugLogResponseInfo({ url: url2.toString(), request: fetch(url2, { ...init, agent: await httpsAgent() }) });
  });
}

// ../cli-kit/src/public/common/ts/deep-required.ts
init_cjs_shims();

// ../cli-kit/src/public/node/monorail.ts
var url = "https://monorail-edge.shopifysvc.com/v1/produce";
var MONORAIL_COMMAND_TOPIC = "app_cli3_command/1.12";
var publishedCommandNames = /* @__PURE__ */ new Set();
async function publishMonorailEvent(schemaId, publicData, sensitiveData) {
  const commandName = publicData.command;
  if (commandName && typeof commandName === "string") {
    if (publishedCommandNames.has(commandName)) {
      return { type: "ok" };
    }
    publishedCommandNames.add(commandName);
  }
  try {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const payload = { ...publicData, ...sensitiveData };
    const body = JSON.stringify({ schema_id: schemaId, payload });
    const headers = buildHeaders2(currentTime);
    const response = await fetch2(url, { method: "POST", body, headers });
    if (response.status === 200) {
      outputDebug(outputContent`Analytics event sent: ${outputToken.json(sanitizePayload(payload))}`);
      return { type: "ok" };
    } else {
      outputDebug(`Failed to report usage analytics: ${response.statusText}`);
      return { type: "error", message: response.statusText };
    }
  } catch (error) {
    let message = "Failed to report usage analytics";
    if (error instanceof Error) {
      message = message.concat(`: ${error.message}`);
    }
    outputDebug(message);
    return { type: "error", message };
  }
}
function sanitizePayload(payload) {
  const result = { ...payload };
  if ("api_key" in result) {
    result.api_key = "****";
  }
  return result;
}
var buildHeaders2 = (currentTime) => {
  return {
    "Content-Type": "application/json; charset=utf-8",
    "X-Monorail-Edge-Event-Created-At-Ms": currentTime.toString(),
    "X-Monorail-Edge-Event-Sent-At-Ms": currentTime.toString()
  };
};

// ../cli-kit/src/private/node/otel-metrics.ts
init_cjs_shims();

// ../cli-kit/src/public/node/vendor/otel-js/service/types.ts
init_cjs_shims();

// ../cli-kit/src/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.ts
init_cjs_shims();

// ../cli-kit/src/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.ts
init_cjs_shims();

// ../cli-kit/src/public/node/vendor/otel-js/export/InstantaneousMetricReader.ts
init_cjs_shims();
var import_sdk_metrics = __toESM(require_src5(), 1);
var import_core = __toESM(require_src3(), 1);
var import_api2 = __toESM(require_src(), 1);

// ../cli-kit/src/public/node/vendor/otel-js/utils/throttle.ts
init_cjs_shims();
function throttle(func, wait, { leading = true, trailing = true } = {}) {
  let lastArgs;
  let result;
  let context;
  let timeout = null;
  let previous = 0;
  function later() {
    previous = leading === false ? 0 : Date.now();
    timeout = null;
    if (lastArgs) {
      result = func.apply(context, lastArgs);
    }
    context = null;
    lastArgs = null;
  }
  return function(...args) {
    const now = Date.now();
    if (!previous && leading === false)
      previous = now;
    const remaining = wait - (now - previous);
    context = this;
    lastArgs = args;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      if (lastArgs) {
        result = func.apply(context, lastArgs);
      }
      context = null;
      lastArgs = null;
    } else if (!timeout && trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

// ../cli-kit/src/public/node/vendor/otel-js/export/InstantaneousMetricReader.ts
var InstantaneousMetricReader = class extends import_sdk_metrics.MetricReader {
  constructor({ exporter, throttleLimit }) {
    super({
      aggregationSelector: exporter.selectAggregation?.bind(exporter),
      aggregationTemporalitySelector: exporter.selectAggregationTemporality?.bind(exporter)
    });
    this._exporter = exporter;
    this.onForceFlush = throttle(
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.onForceFlush,
      throttleLimit
    );
  }
  async onForceFlush() {
    const { resourceMetrics, errors } = await this.collect({});
    if (errors.length > 0) {
      import_api2.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
    }
    return new Promise((resolve, reject) => {
      this._exporter.export(resourceMetrics, (result) => {
        if (result.code === import_core.ExportResultCode.SUCCESS) {
          resolve();
        } else {
          reject(result.error ?? new Error(`InstantaneousMetricReader: metrics export failed (error ${result.error})`));
        }
      });
    });
  }
  async onShutdown() {
    await this._exporter.shutdown();
  }
};

// ../cli-kit/src/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.ts
var import_exporter_metrics_otlp_http = __toESM(require_src6(), 1);
var import_resources = __toESM(require_src4(), 1);
var import_sdk_metrics2 = __toESM(require_src5(), 1);
var import_semantic_conventions = __toESM(require_src2(), 1);
var DefaultMeterProvider = class extends import_sdk_metrics2.MeterProvider {
  constructor({ serviceName, env, throttleLimit, useXhr, otelEndpoint }) {
    super({
      resource: new import_resources.Resource({
        [import_semantic_conventions.SemanticResourceAttributes.SERVICE_NAME]: serviceName
      })
    });
    const opts = {
      // url: OTEL_ENDPOINTS[env as Environment] || OTEL_ENDPOINTS.local,
      // CLI addition
      url: otelEndpoint,
      temporalityPreference: import_sdk_metrics2.AggregationTemporality.DELTA
    };
    if (useXhr) {
      opts.headers = {};
    }
    const exporter = new import_exporter_metrics_otlp_http.OTLPMetricExporter(opts);
    this.addMetricReader(
      new InstantaneousMetricReader({
        exporter,
        throttleLimit
      })
    );
    if (env === "dev") {
      this.addMetricReader(
        new InstantaneousMetricReader({
          exporter: new import_sdk_metrics2.ConsoleMetricExporter(),
          throttleLimit
        })
      );
    }
  }
};

// ../cli-kit/src/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.ts
init_cjs_shims();
var import_sdk_metrics3 = __toESM(require_src5(), 1);

// ../cli-kit/src/public/node/vendor/otel-js/utils/validators.ts
init_cjs_shims();
var import_api3 = __toESM(require_src(), 1);
var validMetricRegex = new RegExp("[^a-zA-Z_][^a-zA-Z0-9_]*");
function isValidMetricName(value) {
  if (validMetricRegex.test(value)) {
    import_api3.diag.warn(
      `Metric name ${value} contains invalid characters and will be dropped.
    Service Names and metric names must conform to the following regex %c[a-zA-Z_][a-zA-Z0-9_]*`,
      "color:red"
    );
    return false;
  }
  return true;
}

// ../cli-kit/src/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.ts
var instrumentationScope = "opentelemetry-js-shopify-web";
var BaseOtelService = class {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({ serviceName, prefixMetric = false, metrics = {}, onRecord, meterProvider }) {
    this.metrics = /* @__PURE__ */ new Map();
    this.recordListeners = /* @__PURE__ */ new Set();
    if (!serviceName) {
      throw new Error("Service name is required.");
    }
    this.serviceName = serviceName;
    this.prefixMetric = prefixMetric;
    if (onRecord)
      this.addOnRecord(onRecord);
    if (!meterProvider) {
      throw new Error("MeterProvider is required.");
    }
    this.meterProvider = meterProvider;
    this.register(metrics);
  }
  getMeterProvider() {
    return this.meterProvider;
  }
  addView(viewOptions) {
    ;
    this.meterProvider._sharedState?.viewRegistry?.addView?.(new import_sdk_metrics3.View(viewOptions));
  }
  record(metricName, value, labels) {
    const recordMetric = this.metrics.get(metricName);
    if (!recordMetric) {
      throw new Error(
        `Service ${this.serviceName} has no metrics registered for name: ${metricName}. Can't record value for unknown metric.`
      );
    }
    recordMetric(value, labels);
  }
  registerMetric(metricName, { type, ...options }) {
    if (this.metrics.has(metricName)) {
      return;
    }
    const meter = this.meterProvider.getMeter(instrumentationScope);
    const name = this.prefixMetric ? `${this.serviceName}_${metricName}` : metricName;
    if (!isValidMetricName(name)) {
      return;
    }
    const createInstrument = () => {
      switch (type) {
        case "Counter" /* Counter */:
          return meter.createCounter(name, options);
        case "UpDownCounter" /* UpDownCounter */:
          return meter.createUpDownCounter(name, options);
        case "Histogram" /* Histogram */: {
          if ("boundaries" in options) {
            this.addView({
              instrumentName: name,
              aggregation: new import_sdk_metrics3.ExplicitBucketHistogramAggregation(options.boundaries, true)
            });
          }
          return meter.createHistogram(name, options);
        }
      }
    };
    this.metrics.set(metricName, (firstValue, firstLabels) => {
      const instrument = createInstrument();
      const record = (value, labels) => {
        const [finalValue, finalLabels] = this.notifyRecordListeners(
          metricName,
          value,
          // ensures an new object is created so we don't mutate the original
          { ...labels }
        );
        if ("record" in instrument) {
          instrument.record(finalValue, finalLabels);
        } else {
          instrument.add(finalValue, finalLabels);
        }
        this.meterProvider.forceFlush({});
      };
      record(firstValue, firstLabels);
      this.metrics.set(metricName, record);
    });
  }
  register(metrics) {
    Object.entries(metrics).forEach(([metricName, options]) => {
      this.registerMetric(metricName, options);
    });
  }
  addOnRecord(onRecord) {
    this.recordListeners.add(onRecord);
    return () => {
      this.recordListeners.delete(onRecord);
    };
  }
  removeOnRecord(onRecord) {
    this.recordListeners.delete(onRecord);
  }
  shutdown() {
    this.metrics.clear();
    this.recordListeners.clear();
    return this.meterProvider.shutdown();
  }
  notifyRecordListeners(metricName, initialValue, initialLabels) {
    return Array.from(this.recordListeners).reduce(
      (recordArgs, listener) => {
        return listener(metricName, ...recordArgs) || recordArgs;
      },
      [initialValue, initialLabels]
    );
  }
};

// ../cli-kit/src/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.ts
var import_api4 = __toESM(require_src(), 1);
var DefaultOtelService = class extends BaseOtelService {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({
    throttleLimit = 5e3,
    env = "local",
    serviceName,
    prefixMetric = false,
    metrics = {},
    onRecord,
    meterProvider,
    useXhr = false,
    // CLI addition
    otelEndpoint
  }) {
    import_api4.diag.setLogger(
      new import_api4.DiagConsoleLogger(),
      ["production", "staging"].includes(env) ? import_api4.DiagLogLevel.ERROR : import_api4.DiagLogLevel.INFO
    );
    super({
      serviceName,
      meterProvider: meterProvider ?? new DefaultMeterProvider({
        serviceName,
        env,
        throttleLimit,
        useXhr,
        // CLI addition
        otelEndpoint
      }),
      prefixMetric,
      metrics,
      onRecord
    });
  }
  shutdown() {
    import_api4.diag.disable();
    return super.shutdown();
  }
};

// ../cli-kit/src/private/node/otel-metrics.ts
var import_api5 = __toESM(require_src(), 1);
async function recordMetrics(options, timing, recorderFactory = createMetricRecorder) {
  const recorder = recorderFactory({
    skipMetricAnalytics: options.skipMetricAnalytics,
    otelOptions: defaultOtelOptions()
  });
  let regularisedCliVersion = options.cliVersion;
  if (options.cliVersion.includes("nightly")) {
    regularisedCliVersion = "nightly";
  } else if (options.cliVersion.includes("pre")) {
    regularisedCliVersion = "pre";
  }
  const labels = {
    exit: options.exitMode,
    job: `${options.owningPlugin}::${options.command}`,
    cli_version: regularisedCliVersion
  };
  recordCommandCounter(recorder, labels);
  recordCommandTiming(recorder, labels, timing);
}
function defaultOtelOptions() {
  return {
    serviceName: "shopify-cli",
    throttleLimit: 1e3,
    prefixMetric: false,
    metrics: {
      ["cli_commands_total" /* Counter */]: {
        type: "Counter" /* Counter */,
        description: "Total number of CLI commands executed",
        valueType: import_api5.ValueType.INT
      },
      ["cli_commands_duration_ms" /* Duration */]: {
        type: "Histogram" /* Histogram */,
        description: "Total time spent in execution of CLI commands. Does not include time spent waiting for network, prompts, etc.",
        valueType: import_api5.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      },
      ["cli_commands_wall_clock_elapsed_ms" /* Elapsed */]: {
        type: "Histogram" /* Histogram */,
        description: "Total time elapsed from start to finish of CLI commands. Includes time spent waiting for network, prompts, etc.",
        valueType: import_api5.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      }
    }
  };
}
function createMetricRecorder(options) {
  let recorder = "console";
  if (!(options.skipMetricAnalytics || isUnitTest() || isSpinEnvironment())) {
    recorder = {
      type: "otel",
      otel: globalOtelService(options)
    };
  }
  return recorder;
}
var _otelService;
function globalOtelService(options) {
  if (!_otelService) {
    _otelService = new DefaultOtelService({
      ...options.otelOptions,
      env: void 0,
      otelEndpoint: `${opentelemetryDomain()}/v1/metrics`
    });
  }
  return _otelService;
}
function recordCommandCounter(recorder, labels) {
  if (recorder === "console") {
    outputDebug(outputContent`[OTEL] record ${"cli_commands_total" /* Counter */} counter ${outputToken.json({ labels })}`);
    return;
  }
  recorder.otel.record("cli_commands_total" /* Counter */, 1, labels);
}
function recordCommandTiming(recorder, labels, timing) {
  if (recorder === "console") {
    outputDebug(
      outputContent`[OTEL] record ${"cli_commands_duration_ms" /* Duration */} histogram ${timing.active.toString()}ms ${outputToken.json({
        labels
      })}`
    );
    outputDebug(outputContent`[OTEL] record ${"cli_commands_wall_clock_elapsed_ms" /* Elapsed */} histogram stage="active" ${timing.active.toString()}ms`);
    outputDebug(outputContent`[OTEL] record ${"cli_commands_wall_clock_elapsed_ms" /* Elapsed */} histogram stage="network" ${timing.network.toString()}ms`);
    outputDebug(outputContent`[OTEL] record ${"cli_commands_wall_clock_elapsed_ms" /* Elapsed */} histogram stage="prompt" ${timing.prompt.toString()}ms`);
    return;
  }
  if (timing.active > 0) {
    recorder.otel.record("cli_commands_duration_ms" /* Duration */, timing.active, labels);
    recorder.otel.record("cli_commands_wall_clock_elapsed_ms" /* Elapsed */, timing.active, { ...labels, stage: "active" });
  }
  if (timing.network > 0) {
    recorder.otel.record("cli_commands_wall_clock_elapsed_ms" /* Elapsed */, timing.network, { ...labels, stage: "network" });
  }
  if (timing.prompt > 0) {
    recorder.otel.record("cli_commands_wall_clock_elapsed_ms" /* Elapsed */, timing.prompt, { ...labels, stage: "prompt" });
  }
}

// ../cli-kit/src/public/node/analytics.ts
async function reportAnalyticsEvent(options) {
  try {
    const payload = await buildPayload(options);
    if (payload === void 0) {
      return;
    }
    const skipMonorailAnalytics = !alwaysLogAnalytics() && analyticsDisabled();
    const skipMetricAnalytics = !alwaysLogMetrics() && analyticsDisabled();
    if (skipMonorailAnalytics || skipMetricAnalytics) {
      outputDebug(outputContent`Skipping command analytics, payload: ${outputToken.json(payload)}`);
    }
    const doMonorail = async () => {
      if (skipMonorailAnalytics) {
        return;
      }
      const response = await publishMonorailEvent(MONORAIL_COMMAND_TOPIC, payload.public, payload.sensitive);
      if (response.type === "error") {
        outputDebug(response.message);
      }
    };
    const doOpenTelemetry = async () => {
      const active = payload.public.cmd_all_timing_active_ms || 0;
      const network = payload.public.cmd_all_timing_network_ms || 0;
      const prompt = payload.public.cmd_all_timing_prompts_ms || 0;
      return recordMetrics(
        {
          skipMetricAnalytics,
          cliVersion: payload.public.cli_version,
          owningPlugin: payload.public.cmd_all_plugin || "@shopify/cli",
          command: payload.public.command,
          exitMode: options.exitMode
        },
        {
          active,
          network,
          prompt
        }
      );
    };
    await Promise.all([doMonorail(), doOpenTelemetry()]);
  } catch (error) {
    let message = "Failed to report usage analytics";
    if (error instanceof Error) {
      message = message.concat(`: ${error.message}`);
    }
    outputDebug(message);
  }
}
async function buildPayload({ config, errorMessage, exitMode }) {
  const { commandStartOptions, environmentFlags, ...sensitiveMetadata } = getAllSensitiveMetadata();
  if (commandStartOptions === void 0) {
    outputDebug("Unable to log analytics event - no information on executed command");
    return;
  }
  const { startCommand, startArgs, startTime } = commandStartOptions;
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  const { "@shopify/cli": internalPluginsPublic, ...externalPluginsPublic } = await fanoutHooks(
    config,
    "public_command_metadata",
    {}
  );
  const { "@shopify/cli": internalPluginsSensitive, ...externalPluginsSensitive } = await fanoutHooks(
    config,
    "sensitive_command_metadata",
    {}
  );
  const environmentData = await getEnvironmentData(config);
  const sensitiveEnvironmentData = await getSensitiveEnvironmentData(config);
  const publicMetadata = getAllPublicMetadata();
  const subTimers = ["cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"];
  const totalTimeFromSubtimers = subTimers.reduce((total, timer) => {
    const value = publicMetadata[timer];
    if (value !== void 0) {
      return total + value;
    }
    return total;
  }, 0);
  const wallClockElapsed = currentTime - startTime;
  const totalTimeWithoutSubtimers = wallClockElapsed - totalTimeFromSubtimers;
  let payload = {
    public: {
      command: startCommand,
      time_start: startTime,
      time_end: currentTime,
      total_time: wallClockElapsed,
      success: exitMode === "ok" && errorMessage === void 0,
      cli_version: CLI_KIT_VERSION,
      ruby_version: await version() || "",
      node_version: process.version.replace("v", ""),
      is_employee: await isShopify(),
      ...environmentData,
      ...internalPluginsPublic,
      ...publicMetadata,
      cmd_all_timing_active_ms: totalTimeWithoutSubtimers,
      cmd_all_exit: exitMode
    },
    sensitive: {
      args: startArgs.join(" "),
      cmd_all_environment_flags: environmentFlags,
      error_message: errorMessage,
      ...internalPluginsSensitive,
      ...sensitiveEnvironmentData,
      metadata: JSON.stringify({
        ...sensitiveMetadata,
        extraPublic: {
          ...externalPluginsPublic
        },
        extraSensitive: { ...externalPluginsSensitive }
      })
    }
  };
  const timingMetrics = ["cmd_all_timing_active_ms", "cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"];
  timingMetrics.forEach((metric) => {
    const current = payload.public[metric];
    if (current !== void 0) {
      payload.public[metric] = Math.floor(current);
    }
  });
  payload = JSON.parse(JSON.stringify(payload));
  return sanitizePayload2(payload);
}
function sanitizePayload2(payload) {
  const payloadString = JSON.stringify(payload);
  const sanitizedPayloadString = payloadString.replace(/shptka_\w*/g, "*****");
  return JSON.parse(sanitizedPayloadString);
}

export {
  getEnvironmentVariables,
  getPartnersToken,
  getOrganization,
  getBackendPort,
  getIdentityTokenInformation,
  execCLI2,
  version,
  RequestClientError,
  GraphQLClientError,
  sanitizedHeadersOutput,
  buildHeaders,
  httpsAgent,
  allAPIs,
  debugLogResponseInfo,
  formData,
  fetch2 as fetch,
  shopifyFetch,
  fanoutHooks,
  getListOfTunnelPlugins,
  reportAnalyticsEvent
};
//# sourceMappingURL=chunk-K3GG6Y3J.js.map
