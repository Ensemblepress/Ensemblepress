import {
  z
} from "./chunk-6UDFXWNE.js";
import {
  AbortError,
  BugError,
  outputInfo,
  renderAutocompletePrompt,
  renderConcurrent,
  renderConfirmationPrompt,
  renderFatalError,
  renderInfo,
  renderSelectPrompt,
  renderSuccess,
  renderTable,
  renderTasks,
  renderTextPrompt,
  renderWarning,
  sleep
} from "./chunk-WAEWSGBK.js";
import {
  init_cjs_shims
} from "./chunk-ZPL24Y2D.js";

// src/cli/services/demo.ts
init_cjs_shims();
function oneOrMore(singular) {
  return z.union([singular, z.array(singular)]);
}
var scalar = z.union([z.string(), z.number(), z.boolean(), z.null(), z.undefined()]);
var linkSchema = z.object({ label: z.string(), url: z.string() });
var inlineTokenSchema = z.union([
  z.string(),
  z.object({ command: z.string() }),
  z.object({ link: linkSchema }),
  z.object({ char: z.string().length(1) }),
  z.object({ userInput: z.string() }),
  z.object({ subdued: z.string() }),
  z.object({ filePath: z.string() }),
  z.object({ bold: z.string() })
]);
var headlineTokenSchema = oneOrMore(
  z.union([
    z.string(),
    z.object({ command: z.string() }),
    z.object({ char: z.string().length(1) }),
    z.object({ userInput: z.string() }),
    z.object({ subdued: z.string() }),
    z.object({ filePath: z.string() })
  ])
);
var inlineTokenItemSchema = oneOrMore(inlineTokenSchema);
var listSchema = z.object({
  list: z.object({
    title: z.string().optional(),
    items: z.array(inlineTokenItemSchema),
    ordered: z.boolean().optional()
  })
});
var tokenItemSchema = oneOrMore(z.union([inlineTokenSchema, listSchema]));
var tableSchema = z.object({
  rows: z.array(z.object({}).catchall(scalar)),
  columns: z.object({}).catchall(
    z.object({
      header: z.string().optional(),
      color: z.string().optional()
    })
  )
});
var infoTableSchema = z.union([
  z.object({}).catchall(z.array(inlineTokenItemSchema)),
  z.array(
    z.object({
      color: z.string().optional(),
      header: z.string(),
      helperText: z.string().optional(),
      bullet: z.string().optional(),
      items: z.array(inlineTokenItemSchema)
    })
  )
]);
var abstractDemoStepSchema = z.object({
  type: z.string(),
  properties: z.object({}),
  // optional properties for documentation purposes
  title: z.string().optional(),
  description: z.string().optional()
});
var outputStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("output"),
  properties: z.object({
    content: z.string()
  })
});
var renderStepPropertiesSchema = z.object({
  headline: headlineTokenSchema.optional(),
  body: tokenItemSchema.optional(),
  nextSteps: z.array(inlineTokenItemSchema).optional(),
  reference: z.array(inlineTokenItemSchema).optional(),
  link: linkSchema.optional(),
  customSections: z.array(
    z.object({
      title: z.string().optional(),
      body: tokenItemSchema
    })
  ).optional(),
  orderedNextSteps: z.boolean().optional()
});
var renderInfoStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("info"),
  properties: renderStepPropertiesSchema
});
var renderSuccessStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("success"),
  properties: renderStepPropertiesSchema
});
var renderWarningStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("warning"),
  properties: renderStepPropertiesSchema
});
var renderFatalErrorStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("fatalError"),
  properties: z.object({
    errorType: z.union([z.literal("abort"), z.literal("bug")]),
    message: z.string(),
    tryMessage: z.string().optional(),
    nextSteps: z.array(inlineTokenItemSchema).optional()
  })
});
var renderTableStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("table"),
  properties: tableSchema
});
var renderAutoCompletePromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("autocompletePrompt"),
  properties: z.object({
    message: z.string(),
    choices: z.array(
      z.object({
        label: z.string(),
        value: z.string()
      })
    )
  })
});
var renderConfirmationPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("confirmationPrompt"),
  properties: z.object({
    message: headlineTokenSchema,
    infoTable: infoTableSchema.optional(),
    defaultValue: z.boolean().optional(),
    confirmationMessage: z.string(),
    cancellationMessage: z.string()
  })
});
var renderSelectPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("selectPrompt"),
  properties: z.object({
    message: headlineTokenSchema,
    choices: z.array(
      z.object({
        label: z.string(),
        value: z.string(),
        key: z.string().length(1).optional(),
        group: z.string().optional(),
        disabled: z.boolean().optional()
      })
    ),
    defaultValue: z.string().optional(),
    infoTable: infoTableSchema.optional()
  })
});
var renderTextPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("textPrompt"),
  properties: z.object({
    message: z.string(),
    defaultValue: z.string().optional(),
    password: z.boolean().optional(),
    allowEmpty: z.boolean().optional()
  })
});
var sleepStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("sleep"),
  properties: z.object({
    duration: z.number()
  })
});
var taskbarStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("taskbar"),
  properties: z.object({
    steps: z.array(
      z.object({
        title: z.string(),
        duration: z.number()
      })
    )
  })
});
var renderConcurrentPropertiesSchema = z.object({
  processes: z.array(
    z.object({
      prefix: z.string(),
      steps: z.array(
        z.object({
          startMessage: z.string().optional(),
          duration: z.number(),
          endMessage: z.string().optional()
        })
      )
    })
  )
});
var renderConcurrentStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("concurrent"),
  properties: renderConcurrentPropertiesSchema
});
var demoStepSchema = z.discriminatedUnion("type", [
  outputStepSchema,
  renderInfoStepSchema,
  renderSuccessStepSchema,
  renderWarningStepSchema,
  renderTableStepSchema,
  renderFatalErrorStepSchema,
  renderAutoCompletePromptStepSchema,
  renderConfirmationPromptStepSchema,
  renderSelectPromptStepSchema,
  renderTextPromptStepSchema,
  sleepStepSchema,
  taskbarStepSchema,
  renderConcurrentStepSchema
]);
var demoStepsSchema = z.object({
  $schema: z.string().optional(),
  command: z.string().optional(),
  steps: z.array(demoStepSchema)
});
async function demo(stepsJsonData) {
  const { steps, command } = demoStepsSchema.parse(stepsJsonData);
  const executors = steps.map(executorForStep);
  await simulateTyping(command);
  for (const executor of executors) {
    await executor();
  }
}
async function simulateTyping(text) {
  if (!text)
    return;
  console.clear();
  process.stdout.write("$ ");
  const chars = text.split("");
  while (chars.length > 0) {
    const char = chars.shift();
    process.stdout.write(char);
    await sleep(0.1 + Math.random() / 10);
  }
  process.stdout.write("\n");
  await sleep(1 + Math.random() / 10);
}
function executorForStep(step) {
  switch (step.type) {
    case "output":
      return async () => {
        outputInfo(step.properties.content);
      };
    case "sleep":
      return async () => {
        await sleep(step.properties.duration);
      };
    case "taskbar":
      return taskbarExecutor(step.properties.steps);
    case "concurrent":
      return concurrentExecutor(step.properties);
    case "info":
      return async () => {
        renderInfo(step.properties);
      };
    case "success":
      return async () => {
        renderSuccess(step.properties);
      };
    case "warning":
      return async () => {
        renderWarning(step.properties);
      };
    case "fatalError":
      return async () => {
        const { errorType, message, nextSteps, tryMessage } = step.properties;
        if (errorType === "abort") {
          renderFatalError(new AbortError(message, tryMessage, nextSteps));
        } else {
          renderFatalError(new BugError(message, tryMessage));
        }
      };
    case "table":
      return async () => {
        renderTable(step.properties);
      };
    case "autocompletePrompt":
      return async () => {
        await renderAutocompletePrompt(step.properties);
      };
    case "confirmationPrompt":
      return async () => {
        await renderConfirmationPrompt(step.properties);
      };
    case "selectPrompt":
      return async () => {
        await renderSelectPrompt(step.properties);
      };
    case "textPrompt":
      return async () => {
        await renderTextPrompt(step.properties);
      };
    default:
      throw new Error(`Unknown step type: ${step.type}`);
  }
}
function taskbarExecutor(steps) {
  return async () => {
    const tasks = steps.map(({ title, duration }) => {
      return {
        title,
        task: async () => sleep(duration)
      };
    });
    await renderTasks(tasks);
  };
}
function concurrentExecutor({ processes }) {
  return async () => {
    const concurrentProcesses = processes.map(({ prefix, steps }) => {
      return {
        prefix,
        action: async (stdout) => {
          for (const step of steps) {
            const { startMessage, duration, endMessage } = step;
            if (startMessage)
              stdout.write(startMessage);
            await sleep(duration);
            if (endMessage)
              stdout.write(endMessage);
          }
        }
      };
    });
    await renderConcurrent({ processes: concurrentProcesses });
  };
}

export {
  demoStepsSchema,
  demo
};
//# sourceMappingURL=chunk-BMTG2VHL.js.map
