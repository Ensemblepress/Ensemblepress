import {
  require_notifier
} from "./chunk-S4VBXFXP.js";
import {
  ClientError,
  fetch,
  require_form_data,
  require_src,
  require_src2,
  require_src3,
  require_src4,
  require_src5,
  require_src6
} from "./chunk-LC6MEJT3.js";
import {
  Conf,
  latestVersion
} from "./chunk-RUSG4O2Z.js";
import {
  require_semver
} from "./chunk-PRJ3U7MR.js";
import {
  Box_default,
  Text,
  ansi_escapes_default,
  ciPlatform,
  cloudEnvironment,
  colorJson,
  copy,
  currentProcessIsGlobal,
  ensureFile,
  execa,
  execaSync,
  figures_default,
  findUp,
  isInteractive,
  macAddress,
  measure_element_default,
  move,
  outputContent,
  outputDebug,
  remove,
  render_default,
  require_cjs,
  require_debounce,
  require_difference,
  require_dist,
  require_gradient_string,
  require_macaddress,
  require_memoize,
  require_node_abort_controller,
  require_react,
  require_sortBy,
  require_stacktracey,
  require_supports_hyperlinks,
  require_uniqBy,
  source_default,
  stripAnsi,
  terminalLink,
  use_app_default,
  use_input_default,
  use_stdin_default,
  use_stdout_default
} from "./chunk-WAEWSGBK.js";
import {
  envPaths
} from "./chunk-WADS2TV5.js";
import {
  require_lib
} from "./chunk-GEN4RXTD.js";
import {
  cwd,
  require_commondir
} from "./chunk-UNPXLODI.js";
import {
  basename,
  dirname,
  extname,
  isAbsolute,
  join,
  normalize,
  relative,
  resolve
} from "./chunk-T5LLJYYS.js";
import {
  __toESM,
  init_cjs_shims
} from "./chunk-ZPL24Y2D.js";

// ../cli-kit/dist/public/node/error-handler.js
init_cjs_shims();

// ../cli-kit/dist/public/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/ruby.js
init_cjs_shims();

// ../cli-kit/dist/public/node/os.js
init_cjs_shims();

// ../cli-kit/dist/public/node/output.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/local.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/spin.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/utilities.js
init_cjs_shims();
function isTruthy(variable) {
  if (!variable) {
    return false;
  }
  return ["1", "true", "TRUE", "yes", "YES"].includes(variable);
}

// ../cli-kit/dist/public/node/fs.js
init_cjs_shims();

// ../cli-kit/dist/public/node/path.js
init_cjs_shims();
var import_commondir = __toESM(require_commondir(), 1);
import { fileURLToPath } from "url";
function joinPath(...paths) {
  return join(...paths);
}
function normalizePath(path) {
  return normalize(path);
}
function resolvePath(...paths) {
  return resolve(...paths);
}
function relativePath(from, to) {
  return relative(from, to);
}
function isAbsolutePath(path) {
  return isAbsolute(path);
}
function dirname2(path) {
  return dirname(path);
}
function basename2(path, ext) {
  return basename(path, ext);
}
function extname2(path) {
  return extname(path);
}
function relativizePath(path, dir = cwd2()) {
  const result = (0, import_commondir.default)([path, dir]);
  const relativePath2 = relative(dir, path);
  const relativeComponents = relativePath2.split("/").filter((component) => component === "..").length;
  if (result === "/" || relativePath2 === "" || relativeComponents > 2) {
    return path;
  } else {
    return relativePath2;
  }
}
function moduleDirectory(moduleURL) {
  return dirname2(fileURLToPath(moduleURL));
}
function cwd2() {
  return normalize(process.env.INIT_CWD ? process.env.INIT_CWD : process.cwd());
}
function sniffForPath(argv = process.argv) {
  const pathFlagIndex = argv.indexOf("--path");
  if (pathFlagIndex === -1) {
    const pathArg = argv.find((arg) => arg.startsWith("--path="));
    return pathArg?.split("=")[1];
  }
  const pathFlag = argv[pathFlagIndex + 1];
  if (!pathFlag || pathFlag.startsWith("-"))
    return;
  return pathFlag;
}

// ../cli-kit/dist/public/common/string.js
init_cjs_shims();

// ../cli-kit/dist/public/common/array.js
init_cjs_shims();
var import_uniqBy = __toESM(require_uniqBy(), 1);
var import_difference = __toESM(require_difference(), 1);

// ../cli-kit/dist/public/common/string.js
var import_change_case = __toESM(require_dist(), 1);
function capitalize(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
function pluralize(items, plural, singular, none) {
  if (items.length === 1) {
    return singular(items[0]);
  }
  if (items.length > 1) {
    return plural(items);
  }
  if (none) {
    return none();
  }
  return "";
}
function linesToColumns(lines) {
  const widths = [];
  for (let i = 0; lines[0] && i < lines[0].length; i++) {
    const columnRows = lines.map((line) => line[i]);
    widths.push(Math.max(...columnRows.map((row) => unstyled(row).length)));
  }
  const paddedLines = lines.map((line) => {
    return line.map((col, index) => {
      return `${col}${" ".repeat(widths[index] - unstyled(col).length)}`;
    }).join("   ").trimEnd();
  }).join("\n");
  return paddedLines;
}
function camelize(input) {
  return (0, import_change_case.camelCase)(input);
}
function hyphenate(input) {
  return (0, import_change_case.paramCase)(input);
}
function underscore(input) {
  return (0, import_change_case.snakeCase)(input);
}

// ../cli-kit/dist/public/node/fs.js
import { mkdirSync as fsMkdirSync, readFileSync as fsReadFileSync, writeFileSync as fsWriteFileSync, appendFileSync as fsAppendFileSync, statSync as fsStatSync, createReadStream as fsCreateReadStream, createWriteStream as fsCreateWriteStream, constants as fsConstants, existsSync as fsFileExistsSync, unlinkSync as fsUnlinkSync } from "fs";
import { mkdir as fsMkdir, writeFile as fsWriteFile, readFile as fsReadFile, realpath as fsRealPath, appendFile as fsAppendFile, mkdtemp as fsMkdtemp, stat as fsStat, lstat as fsLstat, chmod as fsChmod, access as fsAccess, rename as fsRename } from "fs/promises";
async function readFile(path, options = { encoding: "utf8" }) {
  outputDebug2(outputContent2`Reading the content of file at ${outputToken.path(path)}...`);
  return fsReadFile(path, options);
}
function readFileSync(path) {
  outputDebug2(outputContent2`Sync-reading the content of file at ${outputToken.path(path)}...`);
  return fsReadFileSync(path);
}
async function copyFile(from, to) {
  outputDebug2(outputContent2`Copying file from ${outputToken.path(from)} to ${outputToken.path(to)}...`);
  await copy(from, to);
}
async function touchFile(path) {
  outputDebug2(outputContent2`Creating an empty file at ${outputToken.path(path)}...`);
  await ensureFile(path);
}
async function writeFile(path, data, options = { encoding: "utf8" }) {
  outputDebug2(outputContent2`Writing some content to file at ${outputToken.path(path)}...`);
  await fsWriteFile(path, data, options);
}
async function mkdir(path) {
  outputDebug2(outputContent2`Creating directory at ${outputToken.path(path)}...`);
  await fsMkdir(path, { recursive: true });
}
async function removeFile(path) {
  outputDebug2(outputContent2`Removing file at ${outputToken.path(path)}...`);
  await remove(path);
}
async function rmdir(path, options = {}) {
  const { default: del } = await import("./del-KSMMBLCD.js");
  outputDebug2(outputContent2`Removing directory at ${outputToken.path(path)}...`);
  await del(path, { force: options.force });
}
async function isDirectory(path) {
  outputDebug2(outputContent2`Checking if ${outputToken.path(path)} is a directory...`);
  return (await fsLstat(path)).isDirectory();
}
async function fileSize(path) {
  outputDebug2(outputContent2`Getting the size of file file at ${outputToken.path(path)}...`);
  return (await fsStat(path)).size;
}
function fileSizeSync(path) {
  outputDebug2(outputContent2`Sync-getting the size of file file at ${outputToken.path(path)}...`);
  return fsStatSync(path).size;
}
function createFileReadStream(path, options) {
  return fsCreateReadStream(path, options);
}
async function moveFile(src, dest, options = {}) {
  await move(src, dest, options);
}
async function fileExists(path) {
  try {
    await fsAccess(path);
    return true;
  } catch {
    return false;
  }
}
async function glob(pattern, options) {
  const { default: fastGlob } = await import("./out-AS7GH6TC.js");
  let overridenOptions = options;
  if (options?.dot == null) {
    overridenOptions = { ...options, dot: true };
  }
  return fastGlob(pattern, overridenOptions);
}
async function findPathUp(matcher, options) {
  const got = await findUp(matcher, options);
  return got ? normalizePath(got) : void 0;
}

// ../cli-kit/dist/private/node/constants.js
init_cjs_shims();
var identifier = "shopify-cli";
var cacheFolder = () => {
  if (process.env.XDG_CACHE_HOME)
    return process.env.XDG_CACHE_HOME;
  return envPaths(identifier).cache;
};
var environmentVariables = {
  alwaysLogAnalytics: "SHOPIFY_CLI_ALWAYS_LOG_ANALYTICS",
  alwaysLogMetrics: "SHOPIFY_CLI_ALWAYS_LOG_METRICS",
  deviceAuth: "SHOPIFY_CLI_DEVICE_AUTH",
  enableCliRedirect: "SHOPIFY_CLI_ENABLE_CLI_REDIRECT",
  env: "SHOPIFY_CLI_ENV",
  firstPartyDev: "SHOPIFY_CLI_1P_DEV",
  noAnalytics: "SHOPIFY_CLI_NO_ANALYTICS",
  partnersToken: "SHOPIFY_CLI_PARTNERS_TOKEN",
  runAsUser: "SHOPIFY_RUN_AS_USER",
  serviceEnv: "SHOPIFY_SERVICE_ENV",
  skipCliRedirect: "SHOPIFY_CLI_SKIP_CLI_REDIRECT",
  spinInstance: "SPIN_INSTANCE",
  themeToken: "SHOPIFY_CLI_THEME_TOKEN",
  unitTest: "SHOPIFY_UNIT_TEST",
  verbose: "SHOPIFY_FLAG_VERBOSE",
  noThemeBundling: "SHOPIFY_CLI_NO_THEME_BUNDLING",
  bundledThemeCLI: "SHOPIFY_CLI_BUNDLED_THEME_CLI",
  // Variables to detect if the CLI is running in a cloud environment
  codespaces: "CODESPACES",
  codespaceName: "CODESPACE_NAME",
  codespacePortForwardingDomain: "GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN",
  gitpod: "GITPOD_WORKSPACE_URL",
  cloudShell: "CLOUD_SHELL",
  spin: "SPIN",
  spinAppPort: "SERVER_PORT",
  spinAppHost: "SPIN_APP_HOST",
  organization: "SHOPIFY_CLI_ORGANIZATION",
  identityToken: "SHOPIFY_CLI_IDENTITY_TOKEN",
  refreshToken: "SHOPIFY_CLI_REFRESH_TOKEN",
  otelURL: "SHOPIFY_CLI_OTEL_EXPORTER_OTLP_ENDPOINT",
  themeKitAccessDomain: "SHOPIFY_CLI_THEME_KIT_ACCESS_DOMAIN"
};
var pathConstants = {
  executables: {
    dev: "/opt/dev/bin/dev"
  },
  directories: {
    cache: {
      path: () => {
        return cacheFolder();
      },
      vendor: {
        path: () => {
          return joinPath(cacheFolder(), "vendor");
        },
        binaries: () => {
          return joinPath(cacheFolder(), "vendor", "binaries");
        }
      }
    }
  }
};
var sessionConstants = {
  expirationTimeMarginInMinutes: 4
};
var bugsnagApiKey = "9e1e6889176fd0c795d5c659225e0fae";

// ../cli-kit/dist/public/node/system.js
init_cjs_shims();

// ../cli-kit/dist/public/node/error.js
init_cjs_shims();

// ../cli-kit/dist/public/node/ui.js
init_cjs_shims();

// ../cli-kit/dist/public/node/abort.js
init_cjs_shims();
var import_node_abort_controller = __toESM(require_node_abort_controller(), 1);
var AbortController = class extends import_node_abort_controller.AbortController {
};

// ../cli-kit/dist/public/node/metadata.js
init_cjs_shims();
import { performance } from "node:perf_hooks";
function getMetadataErrorHandlingStrategy() {
  if (isUnitTest()) {
    return "bubble";
  }
  return "mute-and-report";
}
function createRuntimeMetadataContainer(defaultPublicMetadata = {}) {
  const raw = {
    sensitive: {},
    public: {
      ...defaultPublicMetadata
    }
  };
  const addPublic = (data) => {
    Object.assign(raw.public, data);
  };
  const addSensitive = (data) => {
    Object.assign(raw.sensitive, data);
  };
  const addMetadata = async (addFn, getFn, onError) => {
    const errorHandling = onError === "auto" ? getMetadataErrorHandlingStrategy() : onError;
    const getAndSet = async () => {
      const data = await getFn();
      addFn(data);
    };
    if (errorHandling === "bubble") {
      await getAndSet();
    } else {
      try {
        await getAndSet();
      } catch (error) {
        const { sendErrorToBugsnag: sendErrorToBugsnag2 } = await import("./error-handler-JFX2TIYX.js");
        await sendErrorToBugsnag2(error, "unexpected_error");
      }
    }
  };
  const durationStack = [];
  return {
    getAllPublicMetadata: () => {
      return { ...raw.public };
    },
    getAllSensitiveMetadata: () => {
      return { ...raw.sensitive };
    },
    addPublicMetadata: async (getData, onError = "auto") => {
      return addMetadata(addPublic, getData, onError);
    },
    addSensitiveMetadata: async (getData, onError = "auto") => {
      return addMetadata(addSensitive, getData, onError);
    },
    runWithTimer: (field) => {
      return async (fn) => {
        durationStack.push(0);
        const start = performance.now();
        try {
          const result = await fn();
          return result;
        } finally {
          let end = performance.now();
          end = Math.max(start, end);
          const wallClockDuration = Math.max(end - start, 0);
          const childDurations = durationStack.pop();
          const duration = Math.max(wallClockDuration - childDurations, 0);
          if (durationStack.length > 0) {
            durationStack[durationStack.length - 1] += wallClockDuration;
          }
          performance.measure(`${field}#measurable`, {
            start,
            duration
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          });
          performance.measure(`${field}#wall`, {
            start,
            end
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          });
          let currentValue = raw.public[field] || 0;
          currentValue += duration;
          raw.public[field] = currentValue;
        }
      };
    }
  };
}
var coreData = createRuntimeMetadataContainer({ cmd_all_timing_network_ms: 0, cmd_all_timing_prompts_ms: 0 });
var { getAllPublicMetadata, getAllSensitiveMetadata, addPublicMetadata, addSensitiveMetadata, runWithTimer } = coreData;

// ../cli-kit/dist/private/node/ui/components/ConcurrentOutput.js
init_cjs_shims();

// ../cli-kit/dist/private/node/demo-recorder.js
init_cjs_shims();
var DemoRecorder = class {
  constructor() {
    this.recorded = [];
    this.sleepStart = Date.now();
    this.command = ["shopify", ...process.argv.slice(2)].join(" ");
  }
  addEvent({ type, properties }) {
    if (type === "taskbar") {
      this.resetSleep();
    } else {
      this.addSleep();
    }
    this.recorded.push({ type, properties: JSON.parse(JSON.stringify(properties)) });
    this.sleepStart = Date.now();
  }
  recordedEventsJson() {
    return JSON.stringify({
      command: this.command,
      steps: this.withFormattedConcurrent(this.recorded)
    }, null, 2);
  }
  addSleep() {
    const duration = (Date.now() - this.sleepStart) / 1e3;
    this.sleepStart = Date.now();
    if (duration > 0.1) {
      this.recorded.push({ type: "sleep", properties: { duration } });
    }
  }
  resetSleep() {
    this.sleepStart = Date.now();
  }
  addOrUpdateConcurrentOutput({ prefix, index, output }) {
    let last = this.recorded[this.recorded.length - 1];
    if (last?.type === "concurrent") {
      this.resetSleep();
    } else {
      const eventProperties = {
        type: "concurrent",
        properties: { processes: [], concurrencyStart: Date.now() }
      };
      this.addEvent(eventProperties);
      last = this.recorded[this.recorded.length - 1];
    }
    const { processes } = last.properties;
    while (processes.length <= index) {
      processes.push({ prefix: "", steps: [] });
    }
    processes[index].prefix = prefix;
    processes[index].steps.push({ timestamp: Date.now(), endMessage: output });
  }
  withFormattedConcurrent(recorded) {
    return recorded.map((event) => {
      if (event.type === "concurrent") {
        const { processes, footer, concurrencyStart } = event.properties;
        const formatted = processes.map(({ prefix, steps }) => {
          let mostRecentTimestamp = concurrencyStart;
          const formattedSteps = steps.map(({ timestamp, endMessage }) => {
            const duration = (timestamp - mostRecentTimestamp) / 1e3;
            mostRecentTimestamp = timestamp;
            return { duration, endMessage };
          });
          return { prefix, steps: formattedSteps };
        });
        return { type: "concurrent", properties: { footer, processes: formatted } };
      }
      return event;
    });
  }
};
var NoopDemoRecorder = class {
  addEvent(_event) {
  }
  recordedEventsJson() {
    return JSON.stringify({ steps: [] }, null, 2);
  }
  addSleep() {
  }
  resetSleep() {
  }
  addOrUpdateConcurrentOutput(..._args) {
  }
};
var _instance;
function ensureInstance() {
  if (!_instance) {
    if (isRecording()) {
      _instance = new DemoRecorder();
    } else {
      _instance = new NoopDemoRecorder();
    }
  }
}
function recordUIEvent(event) {
  ensureInstance();
  _instance.addEvent(event);
}
function resetRecordedSleep() {
  ensureInstance();
  _instance.resetSleep();
}
function printEventsJson() {
  if (isRecording()) {
    ensureInstance();
    _instance.addSleep();
    console.log(_instance.recordedEventsJson());
  }
}
function isRecording() {
  return isTruthy(process.env.RECORD_DEMO);
}

// ../cli-kit/dist/private/node/ui/components/ConcurrentOutput.js
var import_react = __toESM(require_react(), 1);
import { AsyncLocalStorage } from "node:async_hooks";
var outputContextStore = new AsyncLocalStorage();

// ../cli-kit/dist/private/node/ui.js
init_cjs_shims();

// ../cli-kit/dist/public/node/tree-kill.js
init_cjs_shims();
import { exec, spawn } from "child_process";
function treeKill(pid = process.pid, killSignal = "SIGTERM", killRoot = true, callback) {
  const after = callback ?? ((error) => {
    if (error)
      outputDebug2(`Failed to kill process ${pid}: ${error}`);
  });
  printEventsJson();
  adaptedTreeKill(pid, killSignal, killRoot, after);
}
function adaptedTreeKill(pid, killSignal, killRoot, callback) {
  const rootPid = typeof pid === "number" ? pid.toString() : pid;
  if (Number.isNaN(rootPid)) {
    if (callback) {
      return callback(new Error("pid must be a number"));
    } else {
      throw new Error("pid must be a number");
    }
  }
  const tree = {};
  tree[rootPid] = [];
  const pidsToProcess = /* @__PURE__ */ new Set();
  pidsToProcess.add(rootPid);
  switch (process.platform) {
    case "win32":
      exec(`taskkill /pid ${pid} /T /F`, callback);
      break;
    case "darwin":
      buildProcessTree(rootPid, tree, pidsToProcess, function(parentPid) {
        return spawn("pgrep", ["-lfP", parentPid]);
      }, function() {
        killAll(tree, killSignal, rootPid, killRoot, callback);
      });
      break;
    default:
      buildProcessTree(rootPid, tree, pidsToProcess, function(parentPid) {
        return spawn("ps", ["-o", "pid command", "--no-headers", "--ppid", parentPid]);
      }, function() {
        killAll(tree, killSignal, rootPid, killRoot, callback);
      });
      break;
  }
}
function killAll(tree, killSignal, rootPid, killRoot, callback) {
  const killed = /* @__PURE__ */ new Set();
  try {
    Object.keys(tree).forEach(function(pid) {
      tree[pid].forEach(function(pidpid) {
        if (!killed.has(pidpid)) {
          killPid(pidpid, killSignal);
          killed.add(pidpid);
        }
      });
      if (pid === rootPid && killRoot && !killed.has(pid)) {
        killPid(pid, killSignal);
        killed.add(pid);
      }
    });
  } catch (err) {
    if (callback) {
      return callback(err);
    } else {
      throw err;
    }
  }
  if (callback) {
    return callback();
  }
}
function killPid(pid, killSignal) {
  try {
    process.kill(parseInt(pid, 10), killSignal);
  } catch (err) {
    if (err.code !== "ESRCH")
      throw err;
  }
}
function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
  const ps = spawnChildProcessesList(parentPid);
  let allData = "";
  ps.stdout?.on("data", function(data) {
    const dataStr = data.toString("ascii");
    allData += dataStr;
  });
  const onClose = (code) => {
    pidsToProcess.delete(parentPid);
    if (code !== 0) {
      if (pidsToProcess.size === 0) {
        return cb();
      }
      return;
    }
    allData.trim().split("\n").forEach(function(line) {
      const match = line.match(/^(\d+)\s(.*)$/);
      if (match) {
        const pid = match[1];
        const cmd = match[2];
        tree[parentPid].push(pid);
        tree[pid] = [];
        outputDebug2(`Killing process ${pid}: ${cmd}`);
        pidsToProcess.add(pid);
        buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
      }
    });
  };
  ps.on("close", onClose);
}

// ../cli-kit/dist/private/node/ui.js
import { EventEmitter } from "events";
function renderOnce(element, { logLevel = "info", logger = consoleLog, renderOptions }) {
  const { output, unmount } = renderString(element, renderOptions);
  if (output) {
    if (isUnitTest())
      collectLog(logLevel, output);
    outputWhereAppropriate(logLevel, logger, output, { skipUIEvent: true });
  }
  unmount();
  return output;
}
async function render(element, options) {
  const { waitUntilExit } = render_default(element, options);
  await waitUntilExit();
  return new Promise((resolve2) => setImmediate(resolve2));
}
var Stdout = class extends EventEmitter {
  constructor(options) {
    super();
    this.frames = [];
    this.write = (frame) => {
      this.frames.push(frame);
      this._lastFrame = frame;
    };
    this.lastFrame = () => {
      return this._lastFrame;
    };
    this.columns = options.columns ?? 80;
    this.rows = options.rows ?? 80;
  }
};
var renderString = (element, renderOptions) => {
  const columns = isUnitTest() ? 80 : process.stdout.columns;
  const stdout = renderOptions?.stdout ?? new Stdout({ columns });
  const instance2 = render_default(element, {
    stdout,
    debug: true,
    exitOnCtrlC: false,
    patchConsole: false
  });
  return {
    output: stdout.lastFrame(),
    unmount: instance2.unmount
  };
};
function handleCtrlC(input, key, exit = () => treeKill(process.pid, "SIGINT")) {
  if (input === "c" && key.ctrl) {
    exit();
  }
}

// ../cli-kit/dist/private/node/ui/alert.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Alert.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Banner.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/hooks/use-layout.js
init_cjs_shims();
var import_react2 = __toESM(require_react(), 1);
var MIN_FULL_WIDTH = 20;
var MIN_FRACTION_WIDTH = 80;
function useLayout() {
  const { stdout } = use_stdout_default();
  const [layout, setLayout] = (0, import_react2.useState)(calculateLayout(stdout));
  (0, import_react2.useLayoutEffect)(() => {
    if (!stdout) {
      return;
    }
    function onResize() {
      setLayout(calculateLayout(stdout));
    }
    stdout.on("resize", onResize);
    return () => {
      stdout.off("resize", onResize);
    };
  }, []);
  return layout;
}
function calculateLayout(stdout) {
  let fullWidth = stdout?.columns ?? MIN_FRACTION_WIDTH;
  let oneThird = fullWidth;
  let twoThirds = fullWidth;
  if (fullWidth <= MIN_FULL_WIDTH) {
    fullWidth = MIN_FULL_WIDTH;
    oneThird = MIN_FULL_WIDTH;
    twoThirds = MIN_FULL_WIDTH;
  } else if (fullWidth > MIN_FRACTION_WIDTH) {
    oneThird = column({ fullWidth, fraction: [1, 3], minWidth: MIN_FRACTION_WIDTH });
    twoThirds = column({ fullWidth, fraction: [2, 3], minWidth: MIN_FRACTION_WIDTH });
  }
  return {
    fullWidth,
    oneThird,
    twoThirds
  };
}
function column({ fullWidth, fraction, minWidth }) {
  const fractionedWidth = Math.floor(fullWidth / fraction[1] * fraction[0]);
  if (fractionedWidth < minWidth) {
    return minWidth;
  } else {
    return fractionedWidth;
  }
}

// ../cli-kit/dist/private/node/ui/contexts/LinksContext.js
init_cjs_shims();
var import_react3 = __toESM(require_react(), 1);
var LinksContext = import_react3.default.createContext(null);

// ../cli-kit/dist/private/node/ui/components/Banner.js
var import_react4 = __toESM(require_react(), 1);
function typeToColor(type) {
  return {
    success: "green",
    error: "red",
    warning: "yellow",
    info: "dim",
    external_error: "red"
  }[type];
}
var Footnotes = () => {
  const linksContext = (0, import_react4.useContext)(LinksContext);
  if (linksContext === null || linksContext.links.current === null) {
    return null;
  }
  const links = linksContext.links.current;
  const linkIds = Object.keys(links);
  return linkIds.length > 0 ? import_react4.default.createElement(Box_default, { marginBottom: 1, marginTop: -1, flexDirection: "column" }, linkIds.map((id) => import_react4.default.createElement(Text, { key: id }, `[${id}] ${links[id]?.url}`))) : null;
};
var BoxWithBorder = ({ type, children }) => {
  const { twoThirds } = useLayout();
  const links = (0, import_react4.useRef)({});
  return import_react4.default.createElement(
    LinksContext.Provider,
    { value: {
      links,
      addLink: (label, url2) => {
        const id = Object.keys(links.current).find((id2) => links.current[id2].url === url2);
        if (id) {
          return id;
        }
        const newId = (Object.keys(links.current).length + 1).toString();
        links.current = {
          ...links.current,
          [newId]: { label, url: url2 }
        };
        return newId;
      }
    } },
    import_react4.default.createElement(
      Box_default,
      { width: twoThirds, marginBottom: 1, borderStyle: "round", flexDirection: "column", borderColor: typeToColor(type) },
      import_react4.default.createElement(
        Box_default,
        { marginTop: -1, marginLeft: 1 },
        import_react4.default.createElement(Text, null, ` ${type.replace(/_/g, " ")} `)
      ),
      import_react4.default.createElement(Box_default, { flexDirection: "column", paddingY: 1, paddingX: 2, gap: 1 }, children)
    ),
    import_react4.default.createElement(Footnotes, null)
  );
};
var BoxWithTopBottomLines = ({ type, children }) => {
  const { twoThirds } = useLayout();
  let topLineAfterTypeLength = twoThirds - 2 - type.length - 2;
  if (topLineAfterTypeLength < 0)
    topLineAfterTypeLength = 0;
  return import_react4.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, gap: 1 },
    import_react4.default.createElement(
      Text,
      null,
      import_react4.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(2)),
      import_react4.default.createElement(Text, null, ` ${type.replace(/_/g, " ")} `),
      import_react4.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(topLineAfterTypeLength))
    ),
    children,
    import_react4.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(twoThirds))
  );
};
var Banner = ({ children, ...props }) => {
  if (props.type === "external_error") {
    return import_react4.default.createElement(BoxWithTopBottomLines, props, children);
  } else {
    return import_react4.default.createElement(BoxWithBorder, props, children);
  }
};

// ../cli-kit/dist/private/node/ui/components/Link.js
init_cjs_shims();
var import_react5 = __toESM(require_react(), 1);
var import_supports_hyperlinks = __toESM(require_supports_hyperlinks(), 1);
function link(label, url2, linksContext) {
  if (!import_supports_hyperlinks.default.stdout) {
    if (linksContext === null) {
      return label ? `${label} ${source_default.dim(`( ${url2} )`)}` : url2;
    }
    const linkId = linksContext.addLink(label, url2);
    return `${label ?? url2} [${linkId}]`;
  }
  return ansi_escapes_default.link(label ?? url2, url2);
}
var Link = ({ label, url: url2 }) => {
  const linksContext = (0, import_react5.useContext)(LinksContext);
  return import_react5.default.createElement(Text, null, link(label, url2, linksContext));
};

// ../cli-kit/dist/private/node/ui/components/List.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/TokenizedText.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Command.js
init_cjs_shims();
var import_react6 = __toESM(require_react(), 1);
var Command = ({ command }) => {
  return import_react6.default.createElement(
    Text,
    { color: "magentaBright" },
    "`",
    command,
    "`"
  );
};

// ../cli-kit/dist/private/node/ui/components/UserInput.js
init_cjs_shims();
var import_react7 = __toESM(require_react(), 1);
var UserInput = ({ userInput }) => {
  return import_react7.default.createElement(Text, { color: "cyan" }, userInput);
};

// ../cli-kit/dist/private/node/ui/components/FilePath.js
init_cjs_shims();
var import_react8 = __toESM(require_react(), 1);
var FilePath = ({ filePath }) => {
  return import_react8.default.createElement(Text, { italic: true }, filePath);
};

// ../cli-kit/dist/private/node/ui/components/Subdued.js
init_cjs_shims();
var import_react9 = __toESM(require_react(), 1);
var Subdued = ({ subdued }) => {
  return import_react9.default.createElement(Text, { dimColor: true }, subdued);
};

// ../cli-kit/dist/private/node/ui/components/TokenizedText.js
var import_react10 = __toESM(require_react(), 1);
function tokenToBlock(token) {
  return {
    display: typeof token !== "string" && "list" in token ? "block" : "inline",
    value: token
  };
}
function tokenItemToString(token) {
  if (typeof token === "string") {
    return token;
  } else if ("command" in token) {
    return token.command;
  } else if ("link" in token) {
    return token.link.label || token.link.url;
  } else if ("char" in token) {
    return token.char;
  } else if ("userInput" in token) {
    return token.userInput;
  } else if ("subdued" in token) {
    return token.subdued;
  } else if ("filePath" in token) {
    return token.filePath;
  } else if ("list" in token) {
    return token.list.items.map(tokenItemToString).join(" ");
  } else if ("bold" in token) {
    return token.bold;
  } else if ("info" in token) {
    return token.info;
  } else if ("warn" in token) {
    return token.warn;
  } else if ("error" in token) {
    return token.error;
  } else {
    return token.map((item, index) => {
      if (index !== 0 && !(typeof item !== "string" && "char" in item)) {
        return ` ${tokenItemToString(item)}`;
      } else {
        return tokenItemToString(item);
      }
    }).join("");
  }
}
function appendToTokenItem(token, suffix) {
  return Array.isArray(token) ? [...token, { char: suffix }] : [token, { char: suffix }];
}
function splitByDisplayType(acc, item) {
  if (item.display === "block") {
    acc.push([item]);
  } else {
    const last = acc[acc.length - 1];
    if (last && last[0].display === "inline") {
      last.push(item);
    } else {
      acc.push([item]);
    }
  }
  return acc;
}
var InlineBlocks = ({ blocks }) => {
  return import_react10.default.createElement(Text, null, blocks.map((block, blockIndex) => import_react10.default.createElement(
    Text,
    { key: blockIndex },
    blockIndex !== 0 && !(typeof block.value !== "string" && "char" in block.value) && import_react10.default.createElement(Text, null, " "),
    import_react10.default.createElement(TokenizedText, { item: block.value })
  )));
};
var TokenizedText = ({ item }) => {
  if (typeof item === "string") {
    return import_react10.default.createElement(Text, null, item);
  } else if ("command" in item) {
    return import_react10.default.createElement(Command, { command: item.command });
  } else if ("link" in item) {
    return import_react10.default.createElement(Link, { ...item.link });
  } else if ("char" in item) {
    return import_react10.default.createElement(Text, null, item.char[0]);
  } else if ("userInput" in item) {
    return import_react10.default.createElement(UserInput, { userInput: item.userInput });
  } else if ("subdued" in item) {
    return import_react10.default.createElement(Subdued, { subdued: item.subdued });
  } else if ("filePath" in item) {
    return import_react10.default.createElement(FilePath, { filePath: item.filePath });
  } else if ("list" in item) {
    return import_react10.default.createElement(List, { ...item.list });
  } else if ("bold" in item) {
    return import_react10.default.createElement(Text, { bold: true }, item.bold);
  } else if ("info" in item) {
    return import_react10.default.createElement(Text, { color: "blue" }, item.info);
  } else if ("warn" in item) {
    return import_react10.default.createElement(Text, { color: "yellow" }, item.warn);
  } else if ("error" in item) {
    return import_react10.default.createElement(Text, { color: "red" }, item.error);
  } else {
    const groupedItems = item.map(tokenToBlock).reduce(splitByDisplayType, []);
    return groupedItems.length === 1 && groupedItems[0].every((item2) => item2.display === "inline") ? import_react10.default.createElement(InlineBlocks, { blocks: groupedItems[0] }) : import_react10.default.createElement(Box_default, { flexDirection: "column" }, groupedItems.map((items, groupIndex) => {
      if (items[0].display === "inline") {
        return import_react10.default.createElement(InlineBlocks, { blocks: items, key: groupIndex });
      } else {
        return import_react10.default.createElement(List, { key: groupIndex, ...items[0].value.list });
      }
    }));
  }
};

// ../cli-kit/dist/private/node/ui/components/List.js
var import_react11 = __toESM(require_react(), 1);
var DOT = "\u2022";
var List = ({ title, items, margin = true, ordered = false, color, bullet = DOT }) => {
  function isCustomListItem(item) {
    return item.item !== void 0;
  }
  function resolveListItem(item, index) {
    const resolvedItem = {
      index,
      color,
      bullet,
      ordered,
      item
    };
    return isCustomListItem(item) ? {
      ...resolvedItem,
      ...item
    } : resolvedItem;
  }
  const ListItem = ({ item, color: color2, bullet: bullet2, index, ordered: ordered2 }) => {
    return import_react11.default.createElement(
      Box_default,
      { key: index, marginLeft: margin ? 2 : 0 },
      import_react11.default.createElement(Text, { color: color2 }, `${ordered2 ? `${index + 1}.` : bullet2}`),
      import_react11.default.createElement(
        Box_default,
        { flexGrow: 1, marginLeft: 1 },
        import_react11.default.createElement(
          Text,
          { color: color2 },
          import_react11.default.createElement(TokenizedText, { item })
        )
      )
    );
  };
  return import_react11.default.createElement(
    Box_default,
    { flexDirection: "column" },
    title ? import_react11.default.createElement(
      Text,
      { color },
      import_react11.default.createElement(TokenizedText, { item: title })
    ) : null,
    items.map(resolveListItem).map(({ index, item, color: color2, bullet: bullet2, ordered: ordered2 }) => import_react11.default.createElement(ListItem, { key: index, item, color: color2, bullet: bullet2, index, ordered: ordered2 }))
  );
};

// ../cli-kit/dist/private/node/ui/components/Alert.js
var import_react12 = __toESM(require_react(), 1);
var Alert = ({ type, headline, body, nextSteps, reference, link: link2, customSections, orderedNextSteps = false }) => {
  return import_react12.default.createElement(
    Banner,
    { type },
    headline ? import_react12.default.createElement(
      Text,
      { bold: true },
      import_react12.default.createElement(TokenizedText, { item: headline })
    ) : null,
    body ? import_react12.default.createElement(TokenizedText, { item: body }) : null,
    nextSteps && nextSteps.length > 0 ? import_react12.default.createElement(List, { title: "Next steps", items: nextSteps, ordered: orderedNextSteps }) : null,
    reference && reference.length > 0 ? import_react12.default.createElement(List, { title: "Reference", items: reference }) : null,
    link2 ? import_react12.default.createElement(Link, { url: link2.url, label: link2.label }) : null,
    customSections && customSections.length > 0 ? import_react12.default.createElement(Box_default, { flexDirection: "column", gap: 1 }, customSections.map((section, index) => import_react12.default.createElement(
      Box_default,
      { key: index, flexDirection: "column" },
      section.title ? import_react12.default.createElement(Text, { bold: true }, section.title) : null,
      import_react12.default.createElement(TokenizedText, { item: section.body })
    ))) : null
  );
};

// ../cli-kit/dist/private/node/ui/alert.js
var import_react13 = __toESM(require_react(), 1);
var typeToLogLevel = {
  info: "info",
  warning: "warn",
  success: "info",
  error: "error"
};
var typeToLogger = {
  info: consoleLog,
  warning: consoleWarn,
  success: consoleLog,
  error: consoleError
};
function alert({ type, headline, body, nextSteps, reference, link: link2, customSections, orderedNextSteps = false, renderOptions }) {
  const { type: alertType, ...eventProps } = arguments[0];
  recordUIEvent({ type, properties: eventProps });
  return renderOnce(import_react13.default.createElement(Alert, { type, headline, body, nextSteps, reference, link: link2, orderedNextSteps, customSections }), { logLevel: typeToLogLevel[type], logger: typeToLogger[type], renderOptions });
}

// ../cli-kit/dist/private/node/ui/components/FatalError.js
init_cjs_shims();
var import_react14 = __toESM(require_react(), 1);
var import_stacktracey = __toESM(require_stacktracey(), 1);
var FatalError = ({ error }) => {
  let stack;
  let tool;
  if (error instanceof BugError) {
    stack = new import_stacktracey.default(error);
    stack.items.forEach((item) => {
      item.file = cleanSingleStackTracePath(item.file);
    });
    stack = stack.withSources();
    stack = stack.filter((entry) => {
      return !entry.file.includes("@oclif/core");
    }).map((item) => {
      const fileShortComponents = item.fileShort.split("packages/");
      item.fileShort = fileShortComponents.length === 2 ? fileShortComponents[1] : fileShortComponents[0];
      return item;
    });
  }
  if (error instanceof ExternalError) {
    tool = `${error.command} ${error.args.join(" ")}`;
  }
  return import_react14.default.createElement(
    Banner,
    { type: tool ? "external_error" : "error" },
    tool ? import_react14.default.createElement(
      Text,
      null,
      "Error coming from ",
      import_react14.default.createElement(Command, { command: tool })
    ) : null,
    error.formattedMessage ? import_react14.default.createElement(TokenizedText, { item: error.formattedMessage }) : import_react14.default.createElement(Text, null, error.message),
    error.tryMessage ? import_react14.default.createElement(TokenizedText, { item: error.tryMessage }) : null,
    error.nextSteps && error.nextSteps.length > 0 ? import_react14.default.createElement(List, { title: "Next steps", items: error.nextSteps }) : null,
    error.customSections && error.customSections.length > 0 ? import_react14.default.createElement(Box_default, { flexDirection: "column", gap: 1 }, error.customSections.map((section, index) => import_react14.default.createElement(
      Box_default,
      { key: index, flexDirection: "column" },
      section.title ? import_react14.default.createElement(Text, { bold: true }, section.title) : null,
      import_react14.default.createElement(TokenizedText, { item: section.body })
    ))) : null,
    stack && stack.items.length !== 0 ? import_react14.default.createElement(
      Box_default,
      { flexDirection: "column" },
      import_react14.default.createElement(Text, null, "To investigate the issue, examine this stack trace:"),
      stack.items.map((item, index) => import_react14.default.createElement(
        Box_default,
        { flexDirection: "column", key: index, paddingLeft: 2 },
        import_react14.default.createElement(
          Text,
          null,
          "at",
          item.calleeShort ? import_react14.default.createElement(Text, { color: "yellow" }, ` ${item.calleeShort}`) : null,
          item.fileShort ? ` (${item.fileShort}:${item.line})` : null
        ),
        import_react14.default.createElement(
          Box_default,
          { paddingLeft: 2 },
          import_react14.default.createElement(Text, { dimColor: true }, item.sourceLine?.trim())
        )
      ))
    ) : null
  );
};

// ../cli-kit/dist/private/node/ui/components/Table/Table.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Table/Row.js
init_cjs_shims();
var import_react15 = __toESM(require_react(), 1);

// ../cli-kit/dist/private/node/ui/components/Table/Table.js
var import_react16 = __toESM(require_react(), 1);

// ../cli-kit/dist/private/node/ui/components/DangerousConfirmationPrompt.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/TextInput.js
init_cjs_shims();
var import_react17 = __toESM(require_react(), 1);
var TextInput = ({ value: originalValue, defaultValue = "", onChange, placeholder = "", noColor = !shouldDisplayColors(), color = noColor ? void 0 : "cyan", password = false, focus = true }) => {
  const [cursorOffset, setCursorOffset] = (0, import_react17.useState)((originalValue || "").length);
  (0, import_react17.useEffect)(() => {
    setCursorOffset((previousOffset) => {
      const newValue = originalValue || "";
      if (previousOffset > newValue.length - 1) {
        return newValue.length;
      }
      return previousOffset;
    });
  }, [originalValue]);
  const value = password ? "*".repeat(originalValue.length) : originalValue;
  let renderedValue;
  const renderPlaceholder = (value2) => {
    return source_default.inverse(value2[0]) + source_default.dim(value2.slice(1));
  };
  const cursorChar = figures_default.square;
  const defaultCursor = import_react17.default.createElement(Text, { backgroundColor: color }, cursorChar);
  const placeholderText = defaultValue.length > 0 ? defaultValue : placeholder.length > 0 ? placeholder : "";
  const renderedPlaceholder = placeholderText.length > 0 ? renderPlaceholder(placeholderText) : defaultCursor;
  renderedValue = value.split("").map((char, index) => {
    if (index === cursorOffset) {
      return noColor ? cursorChar : source_default.inverse(char);
    } else {
      return char;
    }
  }).join("");
  if (cursorOffset === value.length) {
    renderedValue = import_react17.default.createElement(
      Text,
      null,
      renderedValue,
      defaultCursor
    );
  }
  use_input_default((input, key) => {
    if (key.upArrow || key.downArrow || key.ctrl && input === "c" || key.shift && key.tab || key.return) {
      return;
    } else if (key.tab) {
      if (originalValue.length === 0 && placeholderText) {
        onChange(placeholderText);
        setCursorOffset(placeholderText.length);
        return;
      }
    }
    let nextCursorOffset = cursorOffset;
    let nextValue = originalValue;
    if (key.leftArrow) {
      if (cursorOffset > 0) {
        nextCursorOffset--;
      }
    } else if (key.rightArrow) {
      if (cursorOffset < originalValue.length) {
        nextCursorOffset++;
      }
    } else if (key.backspace || key.delete) {
      if (cursorOffset > 0) {
        nextValue = originalValue.slice(0, cursorOffset - 1) + originalValue.slice(cursorOffset, originalValue.length);
        nextCursorOffset--;
      }
    } else {
      nextValue = originalValue.slice(0, cursorOffset) + input + originalValue.slice(cursorOffset, originalValue.length);
      nextCursorOffset += input.length;
    }
    setCursorOffset(nextCursorOffset);
    if (nextValue !== originalValue) {
      onChange(nextValue);
    }
  }, { isActive: focus });
  return import_react17.default.createElement(Text, { color }, value.length > 0 ? renderedValue : renderedPlaceholder);
};

// ../cli-kit/dist/private/node/ui/components/Prompts/InfoTable.js
init_cjs_shims();
var import_react18 = __toESM(require_react(), 1);
var InfoTable = ({ table }) => {
  const sections = Array.isArray(table) ? table : Object.keys(table).map((header) => ({
    header,
    items: table[header],
    color: void 0,
    helperText: void 0,
    bullet: void 0,
    emptyItemsText: void 0
  }));
  const headerColumnWidth = Math.max(...sections.map((section) => {
    return Math.max(...section.header.split("\n").map((line) => {
      return line.length;
    }));
  }));
  return import_react18.default.createElement(Box_default, { flexDirection: "column" }, sections.map((section, index) => import_react18.default.createElement(
    Box_default,
    { key: index, marginBottom: index === sections.length - 1 ? 0 : 1, flexDirection: "column" },
    section.header.length > 0 && import_react18.default.createElement(
      Box_default,
      { width: headerColumnWidth + 1 },
      import_react18.default.createElement(Text, { color: section.color, bold: true }, capitalize(section.header))
    ),
    import_react18.default.createElement(
      Box_default,
      { flexGrow: 1, flexDirection: "column", gap: 1 },
      section.emptyItemsText && section.items.length === 0 ? import_react18.default.createElement(
        Text,
        { color: section.color },
        import_react18.default.createElement(TokenizedText, { item: { subdued: section.emptyItemsText } })
      ) : import_react18.default.createElement(List, { margin: false, items: section.items, color: section.color, bullet: section.bullet }),
      section.helperText ? import_react18.default.createElement(Text, { color: section.color }, section.helperText) : null
    )
  )));
};

// ../cli-kit/dist/private/node/ui/utilities.js
init_cjs_shims();
function messageWithPunctuation(message) {
  const messageToString = tokenItemToString(message);
  return messageToString.endsWith("?") || messageToString.endsWith(":") || messageToString.endsWith(".") ? message : appendToTokenItem(message, ":");
}

// ../cli-kit/dist/private/node/ui/hooks/use-abort-signal.js
init_cjs_shims();
var import_react19 = __toESM(require_react(), 1);
var noop = () => Promise.resolve();
function useAbortSignal(abortSignal, onAbort = noop) {
  const { exit: unmountInk } = use_app_default();
  const [isAborted, setIsAborted] = (0, import_react19.useState)(false);
  (0, import_react19.useLayoutEffect)(() => {
    abortSignal?.addEventListener("abort", () => {
      const abortWithError = abortSignal?.reason.message === "AbortError" ? void 0 : abortSignal?.reason;
      onAbort(abortWithError).then(() => {
        setIsAborted(true);
        unmountInk(abortWithError);
      }).catch(() => {
      });
    });
  }, []);
  return { isAborted };
}

// ../cli-kit/dist/private/node/ui/hooks/use-prompt.js
init_cjs_shims();
var import_react20 = __toESM(require_react(), 1);
var PromptState;
(function(PromptState2) {
  PromptState2["Idle"] = "idle";
  PromptState2["Loading"] = "loading";
  PromptState2["Submitted"] = "submitted";
  PromptState2["Error"] = "error";
  PromptState2["Cancelled"] = "cancelled";
})(PromptState || (PromptState = {}));
function usePrompt({ initialAnswer }) {
  const [promptState, setPromptState] = (0, import_react20.useState)(PromptState.Idle);
  const [answer, setAnswer] = (0, import_react20.useState)(initialAnswer);
  return {
    promptState,
    setPromptState,
    answer,
    setAnswer
  };
}

// ../cli-kit/dist/private/node/ui/components/DangerousConfirmationPrompt.js
var import_react21 = __toESM(require_react(), 1);

// ../cli-kit/dist/private/node/ui/components/SelectPrompt.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/SelectInput.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Scrollbar.js
init_cjs_shims();
var import_react22 = __toESM(require_react(), 1);
var BACKGROUND_CHAR = "\u2502";
var SCROLLBOX_CHAR = "\u2551";
var Scrollbar = ({ containerHeight, visibleListSectionLength, fullListLength, visibleFromIndex, noColor = !shouldDisplayColors() }) => {
  const displayArrows = containerHeight >= 4 && noColor;
  const visibleToIndex = visibleFromIndex + visibleListSectionLength - 1;
  const fullHeight = displayArrows ? containerHeight - 2 : containerHeight;
  const scrollboxHeight = Math.min(fullHeight - 1, Math.ceil(Math.min(1, visibleListSectionLength / fullListLength) * fullHeight));
  let topBuffer;
  if (visibleToIndex >= fullListLength - 1) {
    topBuffer = fullHeight - scrollboxHeight;
  } else {
    const scrollingLength = fullHeight - scrollboxHeight;
    const scrollableIncrements = fullListLength - visibleListSectionLength;
    topBuffer = Math.max(
      // Never go negative, that causes errors!
      0,
      Math.min(
        // Never have more buffer than filling in all spaces above the scrollbox
        fullHeight - scrollboxHeight,
        Math.round(visibleFromIndex / scrollableIncrements * scrollingLength)
      )
    );
  }
  const bottomBuffer = fullHeight - scrollboxHeight - topBuffer;
  const backgroundChar = noColor ? BACKGROUND_CHAR : " ";
  const scrollboxChar = noColor ? SCROLLBOX_CHAR : " ";
  const bgColor = noColor ? void 0 : "gray";
  const scrollboxColor = noColor ? void 0 : "cyan";
  return import_react22.default.createElement(
    Box_default,
    { flexDirection: "column" },
    displayArrows ? import_react22.default.createElement(Text, null, "\u25B3") : null,
    import_react22.default.createElement(
      Box_default,
      { width: 1 },
      import_react22.default.createElement(Text, { backgroundColor: bgColor }, backgroundChar.repeat(topBuffer))
    ),
    import_react22.default.createElement(
      Box_default,
      { width: 1 },
      import_react22.default.createElement(Text, { backgroundColor: scrollboxColor }, scrollboxChar.repeat(scrollboxHeight))
    ),
    import_react22.default.createElement(
      Box_default,
      { width: 1 },
      import_react22.default.createElement(Text, { backgroundColor: bgColor }, backgroundChar.repeat(bottomBuffer))
    ),
    displayArrows ? import_react22.default.createElement(Text, null, "\u25BD") : null
  );
};

// ../cli-kit/dist/private/node/ui/hooks/use-select-state.js
init_cjs_shims();
var import_react23 = __toESM(require_react(), 1);
import { isDeepStrictEqual } from "node:util";
var OptionMap = class extends Map {
  constructor(options) {
    const items = [];
    let firstItem;
    let previous;
    let index = 0;
    for (const option of options) {
      const item = {
        ...option,
        previous,
        next: void 0,
        index
      };
      if (previous) {
        previous.next = item;
      }
      if (!firstItem) {
        firstItem = item;
      }
      items.push([option.value, item]);
      index++;
      previous = item;
    }
    super(items);
    this.first = firstItem;
  }
};
var reducer = (state, action) => {
  switch (action.type) {
    case "select-next-option": {
      if (typeof state.value === "undefined") {
        return state;
      }
      const item = state.optionMap.get(state.value);
      if (!item) {
        return state;
      }
      let next = item.next;
      while (next && next.disabled) {
        next = next.next;
      }
      if (!next) {
        return state;
      }
      const needsToScroll = next.index > state.visibleToIndex;
      if (!needsToScroll) {
        return {
          ...state,
          value: next.value
        };
      }
      const nextVisibleToIndex = next.index;
      const nextVisibleFromIndex = nextVisibleToIndex - state.visibleOptionCount + 1;
      return {
        ...state,
        value: next.value,
        visibleFromIndex: nextVisibleFromIndex,
        visibleToIndex: nextVisibleToIndex,
        previousValue: state.value
      };
    }
    case "select-previous-option": {
      if (typeof state.value === "undefined") {
        return state;
      }
      const item = state.optionMap.get(state.value);
      if (!item) {
        return state;
      }
      let previous = item.previous;
      while (previous && previous.disabled) {
        previous = previous.previous;
      }
      if (!previous) {
        return state;
      }
      const needsToScroll = previous.index < state.visibleFromIndex;
      if (!needsToScroll) {
        return {
          ...state,
          value: previous.value
        };
      }
      const nextVisibleFromIndex = previous.index;
      const nextVisibleToIndex = nextVisibleFromIndex + state.visibleOptionCount - 1;
      return {
        ...state,
        value: previous.value,
        visibleFromIndex: nextVisibleFromIndex,
        visibleToIndex: nextVisibleToIndex,
        previousValue: state.value
      };
    }
    case "select-option": {
      const item = state.optionMap.get(action.option.value);
      if (!item) {
        return state;
      }
      return {
        ...state,
        value: item.value,
        previousValue: state.value
      };
    }
    case "reset": {
      return action.state;
    }
    default: {
      return state;
    }
  }
};
var createDefaultState = ({ visibleOptionCount: customVisibleOptionCount, defaultValue, options }) => {
  const visibleOptionCount = typeof customVisibleOptionCount === "number" ? Math.min(customVisibleOptionCount, options.length) : options.length;
  const optionMap = new OptionMap(options);
  const defaultOption = typeof defaultValue === "undefined" ? void 0 : optionMap.get(defaultValue);
  let option = defaultOption && !defaultOption.disabled ? defaultOption : optionMap.first;
  while (option && option.disabled) {
    option = option.next;
  }
  return {
    optionMap,
    visibleOptionCount,
    visibleFromIndex: 0,
    visibleToIndex: visibleOptionCount - 1,
    value: option?.value,
    previousValue: option?.value
  };
};
var useSelectState = ({ visibleOptionCount, options, defaultValue }) => {
  const [state, dispatch] = (0, import_react23.useReducer)(reducer, { visibleOptionCount, defaultValue, options }, createDefaultState);
  const [lastOptions, setLastOptions] = (0, import_react23.useState)(options);
  const [lastVisibleOptionCount, setLastVisibleOptionCount] = (0, import_react23.useState)(visibleOptionCount);
  if (options !== lastOptions && !isDeepStrictEqual(options, lastOptions)) {
    dispatch({
      type: "reset",
      state: createDefaultState({ visibleOptionCount, defaultValue, options })
    });
    setLastOptions(options);
  }
  if (visibleOptionCount !== lastVisibleOptionCount) {
    dispatch({
      type: "reset",
      state: createDefaultState({ visibleOptionCount, defaultValue, options })
    });
    setLastVisibleOptionCount(visibleOptionCount);
  }
  const selectNextOption = (0, import_react23.useCallback)(() => {
    dispatch({
      type: "select-next-option"
    });
  }, []);
  const selectPreviousOption = (0, import_react23.useCallback)(() => {
    dispatch({
      type: "select-previous-option"
    });
  }, []);
  const selectOption = (0, import_react23.useCallback)(({ option }) => {
    dispatch({
      type: "select-option",
      option
    });
  }, []);
  const visibleOptions = (0, import_react23.useMemo)(() => {
    return options.slice(state.visibleFromIndex);
  }, [options, state.visibleFromIndex]);
  return {
    visibleFromIndex: state.visibleFromIndex,
    visibleToIndex: state.visibleToIndex,
    value: state.value,
    visibleOptions,
    selectNextOption,
    selectPreviousOption,
    selectOption,
    previousValue: state.previousValue
  };
};

// ../cli-kit/dist/private/node/ui/components/SelectInput.js
var import_react24 = __toESM(require_react(), 1);
var import_sortBy = __toESM(require_sortBy(), 1);
function highlightedLabel(label, term) {
  if (!term) {
    return label;
  }
  const regex = new RegExp(term, "i");
  return label.replace(regex, (match) => {
    return source_default.bold(match);
  });
}
function validateKeys(items) {
  if (items.some((item) => (item.key?.length ?? 0) > 1)) {
    throw new Error("SelectInput: Keys must be a single character");
  }
  if (!items.every((item) => typeof item.key !== "undefined" && item.key.length > 0)) {
    throw new Error("SelectInput: All items must have keys if one does");
  }
}
function Item({ item, previousItem, isSelected, highlightedTerm, enableShortcuts, items, hasAnyGroup, index }) {
  const label = highlightedLabel(item.label, highlightedTerm);
  let title;
  let labelColor;
  if (isSelected) {
    labelColor = "cyan";
  } else if (item.disabled) {
    labelColor = "dim";
  }
  if (typeof previousItem === "undefined" || item.group !== previousItem.group) {
    title = item.group ?? (hasAnyGroup ? "Other" : void 0);
  }
  const showKey = enableShortcuts && item.key && item.key.length > 0;
  return import_react24.default.createElement(
    Box_default,
    { key: index, flexDirection: "column", marginTop: items.indexOf(item) !== 0 && title ? 1 : 0, minHeight: title ? 2 : 1 },
    title ? import_react24.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react24.default.createElement(Text, { bold: true }, title)
    ) : null,
    import_react24.default.createElement(
      Box_default,
      { key: index, marginLeft: hasAnyGroup ? 3 : 0 },
      import_react24.default.createElement(Box_default, { marginRight: 2 }, isSelected ? import_react24.default.createElement(Text, { color: "cyan" }, `>`) : import_react24.default.createElement(Text, null, " ")),
      import_react24.default.createElement(Text, { color: labelColor }, showKey ? `(${item.key}) ${label}` : label)
    )
  );
}
var MAX_AVAILABLE_LINES = 25;
function SelectInputInner({ items: rawItems, initialItems = rawItems, onChange, enableShortcuts = true, focus = true, emptyMessage = "No items to select.", defaultValue, highlightedTerm, loading = false, errorMessage, hasMorePages = false, morePagesMessage, availableLines = MAX_AVAILABLE_LINES, onSubmit, inputFixedAreaRef }, ref) {
  let noItems = false;
  if (rawItems.length === 0) {
    rawItems = [{ label: emptyMessage, value: null, disabled: true }];
    noItems = true;
  }
  const hasAnyGroup = rawItems.some((item) => typeof item.group !== "undefined");
  const items = (0, import_sortBy.default)(rawItems, "group");
  const itemsHaveKeys = items.some((item) => typeof item.key !== "undefined" && item.key.length > 0);
  if (itemsHaveKeys)
    validateKeys(items);
  const availableLinesToUse = Math.min(availableLines, MAX_AVAILABLE_LINES);
  function maximumLinesLostToGroups(items2) {
    const numberOfGroups = new Set(items2.map((item) => item.group).filter((group) => group)).size;
    const maxVisibleGroups = Math.ceil(Math.min((availableLinesToUse + 1) / 3, numberOfGroups + 1));
    return numberOfGroups > 0 ? (maxVisibleGroups - 1) * 2 + 1 : 0;
  }
  const maxLinesLostToGroups = maximumLinesLostToGroups(items);
  const limit = Math.max(2, availableLinesToUse - maxLinesLostToGroups);
  const hasLimit = items.length > limit;
  const state = useSelectState({
    visibleOptionCount: limit,
    options: items,
    defaultValue
  });
  (0, import_react24.useEffect)(() => {
    if (typeof state.value !== "undefined" && state.previousValue !== state.value) {
      onChange?.(items.find((item) => item.value === state.value));
    }
  }, [state.previousValue, state.value, items, onChange]);
  const handleArrows = (key) => {
    if (key.upArrow) {
      state.selectPreviousOption();
    } else if (key.downArrow) {
      state.selectNextOption();
    }
  };
  const handleShortcuts = (0, import_react24.useCallback)((input) => {
    if (state.visibleOptions.map((item) => item.key).includes(input)) {
      const itemWithKey = state.visibleOptions.find((item2) => item2.key === input);
      const item = items.find((item2) => item2.value === itemWithKey?.value);
      if (itemWithKey && !itemWithKey.disabled) {
        if (onSubmit && item) {
          onSubmit(item);
        }
        state.selectOption({ option: itemWithKey });
      }
    }
  }, [items, onSubmit, state]);
  use_input_default((input, key) => {
    handleCtrlC(input, key);
    if (typeof state.value !== "undefined" && key.return) {
      const item = items.find((item2) => item2.value === state.value);
      if (item && onSubmit) {
        onSubmit(item);
      }
    }
    if (enableShortcuts && input.length > 0 && Object.values(key).every((value) => value === false)) {
      handleShortcuts(input);
    } else {
      handleArrows(key);
    }
  }, { isActive: focus });
  const { twoThirds } = useLayout();
  if (loading) {
    return import_react24.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react24.default.createElement(Text, { dimColor: true }, "Loading...")
    );
  } else if (errorMessage && errorMessage.length > 0) {
    return import_react24.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react24.default.createElement(Text, { color: "red" }, errorMessage)
    );
  } else {
    const optionsHeight = initialItems.length + maximumLinesLostToGroups(initialItems);
    const minHeight = hasAnyGroup ? 5 : 2;
    const sectionHeight = Math.max(minHeight, Math.min(availableLinesToUse, optionsHeight));
    return import_react24.default.createElement(
      Box_default,
      { flexDirection: "column", ref, gap: 1, width: twoThirds },
      import_react24.default.createElement(
        Box_default,
        { flexDirection: "row", height: sectionHeight, width: "100%" },
        import_react24.default.createElement(Box_default, { flexDirection: "column", overflowY: "hidden", flexGrow: 1 }, state.visibleOptions.map((item, index) => import_react24.default.createElement(Item, { key: index, item, previousItem: state.visibleOptions[index - 1], highlightedTerm, isSelected: item.value === state.value, items: state.visibleOptions, enableShortcuts, hasAnyGroup, index }))),
        hasLimit ? import_react24.default.createElement(Scrollbar, { containerHeight: sectionHeight, visibleListSectionLength: limit, fullListLength: items.length, visibleFromIndex: state.visibleFromIndex }) : null
      ),
      import_react24.default.createElement(Box_default, { ref: inputFixedAreaRef }, noItems ? import_react24.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react24.default.createElement(Text, { dimColor: true }, "Try again with a different keyword.")
      ) : import_react24.default.createElement(
        Box_default,
        { marginLeft: 3, flexDirection: "column" },
        import_react24.default.createElement(Text, { dimColor: true }, `Press ${figures_default.arrowUp}${figures_default.arrowDown} arrows to select, enter ${itemsHaveKeys ? "or a shortcut " : ""}to confirm.`),
        hasMorePages ? import_react24.default.createElement(
          Text,
          null,
          import_react24.default.createElement(
            Text,
            { bold: true },
            "1-",
            items.length,
            " of many"
          ),
          morePagesMessage ? `  ${morePagesMessage}` : null
        ) : null
      ))
    );
  }
}
var SelectInput = (0, import_react24.forwardRef)(SelectInputInner);

// ../cli-kit/dist/private/node/ui/components/Prompts/PromptLayout.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Prompts/InfoMessage.js
init_cjs_shims();
var import_react25 = __toESM(require_react(), 1);
var InfoMessage = ({ message: { title: { color, text: title }, body } }) => {
  return import_react25.default.createElement(
    Box_default,
    { flexDirection: "column", gap: 1 },
    import_react25.default.createElement(
      Text,
      { color },
      import_react25.default.createElement(TokenizedText, { item: title })
    ),
    import_react25.default.createElement(TokenizedText, { item: body })
  );
};

// ../cli-kit/dist/private/node/ui/components/Prompts/PromptLayout.js
var import_react26 = __toESM(require_react(), 1);
var PromptLayout = ({ message, infoTable, abortSignal, infoMessage, header, state, input, submittedAnswerLabel }) => {
  const { stdout } = use_stdout_default();
  const [wrapperHeight, setWrapperHeight] = (0, import_react26.useState)(0);
  const [promptAreaHeight, setPromptAreaHeight] = (0, import_react26.useState)(0);
  const [inputFixedAreaHeight, setInputFixedAreaHeight] = (0, import_react26.useState)(0);
  const currentAvailableLines = stdout.rows - promptAreaHeight - inputFixedAreaHeight;
  const [availableLines, setAvailableLines] = (0, import_react26.useState)(currentAvailableLines);
  const wrapperRef = (0, import_react26.useCallback)((node) => {
    if (node !== null) {
      const { height } = measure_element_default(node);
      if (wrapperHeight !== height) {
        setWrapperHeight(height);
      }
    }
  }, [wrapperHeight]);
  const promptAreaRef = (0, import_react26.useCallback)((node) => {
    if (node !== null) {
      const { height } = measure_element_default(node);
      setPromptAreaHeight(height);
    }
  }, []);
  const inputFixedAreaRef = (0, import_react26.useCallback)((node) => {
    if (node !== null) {
      const { height } = measure_element_default(node);
      setInputFixedAreaHeight(height + 3);
    }
  }, []);
  const inputComponent = (0, import_react26.cloneElement)(input, { availableLines, inputFixedAreaRef });
  (0, import_react26.useLayoutEffect)(() => {
    function onResize() {
      const newAvailableLines = stdout.rows - promptAreaHeight - inputFixedAreaHeight;
      if (newAvailableLines !== availableLines) {
        setAvailableLines(newAvailableLines);
      }
    }
    onResize();
    stdout.on("resize", onResize);
    return () => {
      stdout.off("resize", onResize);
    };
  }, [wrapperHeight, promptAreaHeight, stdout, availableLines, inputFixedAreaHeight]);
  const { isAborted } = useAbortSignal(abortSignal);
  const showInfoTable = infoTable && Object.keys(infoTable).length > 0;
  return isAborted ? null : import_react26.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, ref: wrapperRef },
    import_react26.default.createElement(
      Box_default,
      { ref: promptAreaRef, flexDirection: "column" },
      import_react26.default.createElement(
        Box_default,
        null,
        import_react26.default.createElement(
          Box_default,
          { marginRight: 2 },
          import_react26.default.createElement(Text, null, "?")
        ),
        import_react26.default.createElement(TokenizedText, { item: messageWithPunctuation(message) }),
        header
      ),
      (showInfoTable || infoMessage) && state !== PromptState.Submitted ? import_react26.default.createElement(
        Box_default,
        { marginTop: 1, marginLeft: 3, paddingLeft: 2, borderStyle: "bold", borderLeft: true, borderRight: false, borderTop: false, borderBottom: false, flexDirection: "column", gap: 1 },
        infoMessage ? import_react26.default.createElement(InfoMessage, { message: infoMessage }) : null,
        showInfoTable ? import_react26.default.createElement(InfoTable, { table: infoTable }) : null
      ) : null
    ),
    state === PromptState.Submitted && submittedAnswerLabel ? import_react26.default.createElement(
      Box_default,
      null,
      import_react26.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react26.default.createElement(Text, { color: "cyan" }, figures_default.tick)
      ),
      import_react26.default.createElement(Text, { color: "cyan" }, submittedAnswerLabel)
    ) : import_react26.default.createElement(Box_default, { marginTop: 1 }, inputComponent)
  );
};

// ../cli-kit/dist/private/node/ui/components/SelectPrompt.js
var import_react27 = __toESM(require_react(), 1);
function SelectPrompt({ message, choices, infoTable, infoMessage, onSubmit, defaultValue, abortSignal }) {
  if (choices.length === 0) {
    throw new Error("SelectPrompt requires at least one choice");
  }
  const { exit: unmountInk } = use_app_default();
  const { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer: void 0
  });
  const submitAnswer = (0, import_react27.useCallback)((answer2) => {
    setAnswer(answer2);
    setPromptState(PromptState.Submitted);
  }, [setAnswer, setPromptState]);
  (0, import_react27.useEffect)(() => {
    if (promptState === PromptState.Submitted && answer) {
      unmountInk();
      onSubmit(answer.value);
    }
  }, [answer, onSubmit, promptState, unmountInk]);
  return import_react27.default.createElement(PromptLayout, { message, state: promptState, submittedAnswerLabel: answer?.label, infoTable, infoMessage, abortSignal, input: import_react27.default.createElement(SelectInput, { defaultValue, items: choices, onSubmit: submitAnswer }) });
}

// ../cli-kit/dist/private/node/ui/components/Tasks.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/TextAnimation.js
init_cjs_shims();
var import_react28 = __toESM(require_react(), 1);
var import_gradient_string = __toESM(require_gradient_string(), 1);
function rainbow(text, frame) {
  const hue = 5 * frame;
  const leftColor = { h: hue % 360, s: 0.8, v: 1 };
  const rightColor = { h: (hue + 1) % 360, s: 0.8, v: 1 };
  return (0, import_gradient_string.default)(leftColor, rightColor)(text, { interpolation: "hsv", hsvSpin: "long" });
}
var TextAnimation = (0, import_react28.memo)(({ text }) => {
  const frame = (0, import_react28.useRef)(0);
  const [renderedFrame, setRenderedFrame] = (0, import_react28.useState)(text);
  const timeout = (0, import_react28.useRef)();
  const renderAnimation = (0, import_react28.useCallback)(() => {
    const newFrame = frame.current + 1;
    frame.current = newFrame;
    setRenderedFrame(rainbow(text, frame.current));
    timeout.current = setTimeout(() => {
      renderAnimation();
    }, 35);
  }, [text]);
  (0, import_react28.useLayoutEffect)(() => {
    renderAnimation();
    return () => {
      clearTimeout(timeout.current);
    };
  }, [renderAnimation]);
  return import_react28.default.createElement(Text, null, renderedFrame);
});
TextAnimation.displayName = "TextAnimation";

// ../cli-kit/dist/private/node/ui/hooks/use-async-and-unmount.js
init_cjs_shims();
var import_react29 = __toESM(require_react(), 1);
function useAsyncAndUnmount(asyncFunction, { onFulfilled = () => {
}, onRejected = () => {
} } = {}) {
  const { exit: unmountInk } = use_app_default();
  (0, import_react29.useEffect)(() => {
    asyncFunction().then(() => {
      onFulfilled();
      unmountInk();
    }).catch((error) => {
      onRejected(error);
      unmountInk(error);
    });
  }, []);
}

// ../cli-kit/dist/private/node/ui/components/Tasks.js
var import_react30 = __toESM(require_react(), 1);
var loadingBarChar = "\u2580";
var TasksState;
(function(TasksState2) {
  TasksState2["Loading"] = "loading";
  TasksState2["Success"] = "success";
  TasksState2["Failure"] = "failure";
})(TasksState || (TasksState = {}));
async function runTask(task, ctx) {
  task.retryCount = 0;
  task.errors = [];
  const retry = task?.retry && task?.retry > 0 ? task.retry + 1 : 1;
  for (let retries = 1; retries <= retry; retries++) {
    try {
      if (task.skip?.(ctx)) {
        return;
      }
      return await task.task(ctx, task);
    } catch (error) {
      if (retries === retry) {
        throw error;
      } else {
        task.errors.push(error);
        task.retryCount = retries;
      }
    }
  }
}
var noop2 = () => {
};
function Tasks({ tasks, silent = isUnitTest(), onComplete = noop2, abortSignal }) {
  const { twoThirds } = useLayout();
  const loadingBar = new Array(twoThirds).fill(loadingBarChar).join("");
  const [currentTask, setCurrentTask] = (0, import_react30.useState)(tasks[0]);
  const [state, setState] = (0, import_react30.useState)(TasksState.Loading);
  const ctx = (0, import_react30.useRef)({});
  const { isRawModeSupported } = use_stdin_default();
  const runTasks = async () => {
    for (const task of tasks) {
      setCurrentTask(task);
      const subTasks = await runTask(task, ctx.current);
      if (Array.isArray(subTasks) && subTasks.length > 0 && subTasks.every((task2) => "task" in task2)) {
        for (const subTask of subTasks) {
          setCurrentTask(subTask);
          await runTask(subTask, ctx.current);
        }
      }
    }
  };
  useAsyncAndUnmount(runTasks, {
    onFulfilled: () => {
      setState(TasksState.Success);
      onComplete(ctx.current);
    },
    onRejected: () => {
      setState(TasksState.Failure);
    }
  });
  use_input_default((input, key) => {
    handleCtrlC(input, key);
    if (key.return) {
      return null;
    }
  }, { isActive: Boolean(isRawModeSupported) });
  const { isAborted } = useAbortSignal(abortSignal);
  if (silent) {
    return null;
  }
  return state === TasksState.Loading && !isAborted ? import_react30.default.createElement(
    Box_default,
    { flexDirection: "column" },
    import_react30.default.createElement(TextAnimation, { text: loadingBar }),
    import_react30.default.createElement(
      Text,
      null,
      currentTask.title,
      " ..."
    )
  ) : null;
}

// ../cli-kit/dist/private/node/ui/components/TextPrompt.js
init_cjs_shims();
var import_react31 = __toESM(require_react(), 1);
var TextPrompt = ({ message, onSubmit, validate, defaultValue = "", password = false, allowEmpty = false, emptyDisplayedValue = "(empty)", abortSignal, preview, initialAnswer = "" }) => {
  if (password && defaultValue) {
    throw new Error("Can't use defaultValue with password");
  }
  const validateAnswer = (0, import_react31.useCallback)((value) => {
    if (validate) {
      return validate(value);
    }
    if (value.length === 0 && !allowEmpty)
      return "Type an answer to the prompt.";
    return void 0;
  }, [allowEmpty, validate]);
  const { oneThird } = useLayout();
  const { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer
  });
  const answerOrDefault = answer.length > 0 ? answer : defaultValue;
  const displayEmptyValue = answerOrDefault === "";
  const displayedAnswer = displayEmptyValue ? emptyDisplayedValue : answerOrDefault;
  const { exit: unmountInk } = use_app_default();
  const [error, setError] = (0, import_react31.useState)(void 0);
  const color = promptState === PromptState.Error ? "red" : "cyan";
  const underline = new Array(oneThird - 3).fill("\u2594");
  const { isAborted } = useAbortSignal(abortSignal);
  use_input_default((input, key) => {
    handleCtrlC(input, key);
    if (key.return) {
      const error2 = validateAnswer(answerOrDefault);
      if (error2) {
        setPromptState(PromptState.Error);
        setError(error2);
      } else {
        setPromptState(PromptState.Submitted);
      }
    }
  });
  (0, import_react31.useEffect)(() => {
    if (promptState === PromptState.Submitted) {
      onSubmit(answerOrDefault);
      unmountInk();
    }
  }, [answerOrDefault, onSubmit, promptState, unmountInk]);
  return isAborted ? null : import_react31.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, width: oneThird },
    import_react31.default.createElement(
      Box_default,
      null,
      import_react31.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react31.default.createElement(Text, null, "?")
      ),
      import_react31.default.createElement(TokenizedText, { item: messageWithPunctuation(message) })
    ),
    promptState === PromptState.Submitted ? import_react31.default.createElement(
      Box_default,
      null,
      import_react31.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react31.default.createElement(Text, { color: "cyan" }, figures_default.tick)
      ),
      import_react31.default.createElement(
        Box_default,
        { flexGrow: 1 },
        import_react31.default.createElement(Text, { color: "cyan", dimColor: displayEmptyValue }, password ? "*".repeat(answer.length) : displayedAnswer)
      )
    ) : import_react31.default.createElement(
      Box_default,
      { flexDirection: "column" },
      import_react31.default.createElement(
        Box_default,
        null,
        import_react31.default.createElement(
          Box_default,
          { marginRight: 2 },
          import_react31.default.createElement(Text, { color }, `>`)
        ),
        import_react31.default.createElement(
          Box_default,
          { flexGrow: 1 },
          import_react31.default.createElement(TextInput, { value: answer, onChange: (answer2) => {
            setAnswer(answer2);
            setPromptState(PromptState.Idle);
          }, defaultValue, color, password })
        )
      ),
      import_react31.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react31.default.createElement(Text, { color }, underline)
      ),
      promptState === PromptState.Error ? import_react31.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react31.default.createElement(Text, { color }, error)
      ) : null,
      promptState !== PromptState.Error && preview ? import_react31.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react31.default.createElement(TokenizedText, { item: preview(answerOrDefault) })
      ) : null
    )
  );
};

// ../cli-kit/dist/private/node/ui/components/AutocompletePrompt.js
init_cjs_shims();

// ../cli-kit/dist/public/common/function.js
init_cjs_shims();
var import_memoize = __toESM(require_memoize(), 1);
var import_debounce = __toESM(require_debounce(), 1);

// ../cli-kit/dist/private/node/ui/components/AutocompletePrompt.js
var import_react32 = __toESM(require_react(), 1);

// ../cli-kit/dist/public/node/ui.js
var import_react33 = __toESM(require_react(), 1);
var defaultUIDebugOptions = {
  skipTTYCheck: false
};
function renderInfo(options) {
  return alert({ ...options, type: "info" });
}
function renderSuccess(options) {
  return alert({ ...options, type: "success" });
}
function renderWarning(options) {
  return alert({ ...options, type: "warning" });
}
function renderFatalError(error, { renderOptions } = {}) {
  recordUIEvent({
    type: "fatalError",
    properties: { ...error, errorType: error.type === FatalErrorType.Bug ? "bug" : "abort" }
  });
  return renderOnce(import_react33.default.createElement(FatalError, { error }), { logLevel: "error", logger: consoleError, renderOptions });
}
async function renderSelectPrompt({ renderOptions, isConfirmationPrompt, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions);
  if (!isConfirmationPrompt) {
    recordUIEvent({ type: "selectPrompt", properties: { renderOptions, ...props } });
  }
  return runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let selectedValue;
    try {
      await render(import_react33.default.createElement(SelectPrompt, { ...props, onSubmit: (value) => {
        selectedValue = value;
      } }), {
        ...renderOptions,
        exitOnCtrlC: false
      });
      return selectedValue;
    } finally {
      resetRecordedSleep();
    }
  });
}
async function renderConfirmationPrompt({ message, infoTable, confirmationMessage = "Yes, confirm", cancellationMessage = "No, cancel", renderOptions, defaultValue = true, abortSignal, infoMessage }) {
  recordUIEvent({ type: "confirmationPrompt", properties: arguments[0] });
  const choices = [
    {
      label: confirmationMessage,
      value: true,
      key: "y"
    },
    {
      label: cancellationMessage,
      value: false,
      key: "n"
    }
  ];
  return renderSelectPrompt({
    choices,
    message,
    infoTable,
    renderOptions,
    defaultValue,
    isConfirmationPrompt: true,
    abortSignal,
    infoMessage
  });
}
async function renderTasks(tasks, { renderOptions } = {}) {
  recordUIEvent({
    type: "taskbar",
    properties: {
      // Rather than timing exactly, pretend each step takes 2 seconds. This
      // should be easy to tweak manually.
      steps: tasks.map((task) => {
        return { title: task.title, duration: 2 };
      })
    }
  });
  return new Promise((resolve2, reject) => {
    render(import_react33.default.createElement(Tasks, { tasks, onComplete: resolve2 }), {
      ...renderOptions,
      exitOnCtrlC: false
    }).then(() => resetRecordedSleep()).catch(reject);
  });
}
async function renderTextPrompt({ renderOptions, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions);
  recordUIEvent({ type: "textPrompt", properties: arguments[0] });
  return runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let enteredText = "";
    try {
      await render(import_react33.default.createElement(TextPrompt, { ...props, onSubmit: (value) => {
        enteredText = value;
      } }), {
        ...renderOptions,
        exitOnCtrlC: false
      });
      return enteredText;
    } finally {
      resetRecordedSleep();
    }
  });
}
var keypress = async (stdin = process.stdin, uiDebugOptions = defaultUIDebugOptions) => {
  throwInNonTTY({ message: "Press any key" }, uiDebugOptions);
  return runWithTimer("cmd_all_timing_prompts_ms")(() => {
    return new Promise((resolve2, reject) => {
      const handler2 = (buffer) => {
        stdin.setRawMode(false);
        const bytes = Array.from(buffer);
        if (bytes.length && bytes[0] === 3) {
          outputDebug2("Canceled keypress, User pressed CTRL+C");
          reject(new AbortSilentError());
        }
        stdin.unref();
        process.nextTick(resolve2);
      };
      stdin.setRawMode(true);
      stdin.once("data", handler2);
      stdin.ref();
    });
  });
};
function isTTY({ stdin = void 0, uiDebugOptions = defaultUIDebugOptions }) {
  return Boolean(uiDebugOptions.skipTTYCheck || stdin || terminalSupportsRawMode());
}
function throwInNonTTY({ message, stdin = void 0 }, uiDebugOptions) {
  if (isTTY({ stdin, uiDebugOptions }))
    return;
  const promptText = tokenItemToString(message);
  const errorMessage = `Failed to prompt:

${outputContent2`${outputToken.cyan(promptText)}`.value}

This usually happens when running a command non-interactively, for example in a CI environment, or when piping input from another process.`;
  throw new AbortError(errorMessage, "To resolve this, specify the option in the command, or run the command in an interactive environment such as your local terminal.");
}

// ../cli-kit/dist/public/node/error.js
var import_core = __toESM(require_lib(), 1);
var import_ts_error = __toESM(require_cjs(), 1);
var FatalErrorType;
(function(FatalErrorType2) {
  FatalErrorType2[FatalErrorType2["Abort"] = 0] = "Abort";
  FatalErrorType2[FatalErrorType2["AbortSilent"] = 1] = "AbortSilent";
  FatalErrorType2[FatalErrorType2["Bug"] = 2] = "Bug";
})(FatalErrorType || (FatalErrorType = {}));
var CancelExecution = class extends Error {
};
var FatalError2 = class extends Error {
  /**
   * Creates a new FatalError error.
   *
   * @param message - The error message.
   * @param type - The type of fatal error.
   * @param tryMessage - The message that recommends next steps to the user.
   * You can pass a string a {@link TokenizedString} or a {@link TokenItem}
   * if you need to style the message inside the error Banner component.
   * @param nextSteps - Message to show as "next steps" with suggestions to solve the issue.
   * @param customSections - Custom sections to show in the error banner. To be used if nextSteps is not enough.
   */
  constructor(message, type, tryMessage = null, nextSteps, customSections) {
    const messageIsOutputMessage = typeof message === "string" || "value" in message;
    super(messageIsOutputMessage ? stringifyMessage(message) : tokenItemToString(message));
    if (tryMessage) {
      if (tryMessage instanceof TokenizedString) {
        this.tryMessage = stringifyMessage(tryMessage);
      } else {
        this.tryMessage = tryMessage;
      }
    } else {
      this.tryMessage = null;
    }
    this.type = type;
    this.nextSteps = nextSteps;
    this.customSections = customSections;
    this.skipOclifErrorHandling = true;
    if (!messageIsOutputMessage) {
      this.formattedMessage = message;
    }
  }
};
var AbortError = class extends FatalError2 {
  constructor(message, tryMessage = null, nextSteps, customSections) {
    super(message, FatalErrorType.Abort, tryMessage, nextSteps, customSections);
  }
};
var ExternalError = class extends FatalError2 {
  constructor(message, command, args, tryMessage = null) {
    super(message, FatalErrorType.Abort, tryMessage);
    this.command = command;
    this.args = args;
  }
};
var AbortSilentError = class extends FatalError2 {
  constructor() {
    super("", FatalErrorType.AbortSilent);
  }
};
var BugError = class extends FatalError2 {
  constructor(message, tryMessage = null) {
    super(message, FatalErrorType.Bug, tryMessage);
  }
};
async function handler(error) {
  let fatal;
  if (isFatal(error)) {
    fatal = error;
  } else if (typeof error === "string") {
    fatal = new BugError(error);
  } else if (error instanceof Error) {
    fatal = new BugError(error.message);
    fatal.stack = error.stack;
  } else {
    const maybeError = error;
    fatal = new BugError(maybeError?.message ?? "Unknown error");
    if (maybeError?.stack) {
      fatal.stack = maybeError?.stack;
    }
  }
  renderFatalError(fatal);
  return Promise.resolve(error);
}
function errorMapper(error) {
  if (error instanceof import_core.Errors.CLIError) {
    const mappedError = new AbortError(error.message);
    mappedError.stack = error.stack;
    return Promise.resolve(mappedError);
  } else {
    return Promise.resolve(error);
  }
}
function isFatal(error) {
  try {
    return Object.prototype.hasOwnProperty.call(error, "type");
  } catch {
    return false;
  }
}
function shouldReportError(error) {
  if (!isFatal(error)) {
    return true;
  }
  if (error.type === FatalErrorType.Bug) {
    return true;
  }
  return false;
}
function cleanSingleStackTracePath(filePath) {
  return normalizePath(filePath).replace("file:/", "/").replace(/^\/?[A-Z]:/, "");
}

// ../cli-kit/dist/public/node/system.js
async function openURL(url2) {
  const externalOpen = await import("./open-JRS7RW22.js");
  await externalOpen.default(url2);
}
async function captureOutput(command, args, options) {
  const result = await buildExec(command, args, options);
  return result.stdout;
}
async function exec2(command, args, options) {
  const commandProcess = buildExec(command, args, options);
  if (options?.stderr && options.stderr !== "inherit") {
    commandProcess.stderr?.pipe(options.stderr, { end: false });
  }
  if (options?.stdout && options.stdout !== "inherit") {
    commandProcess.stdout?.pipe(options.stdout, { end: false });
  }
  let aborted = false;
  options?.signal?.addEventListener("abort", () => {
    const pid = commandProcess.pid;
    if (pid) {
      outputDebug2(`Killing process ${pid}: ${command} ${args.join(" ")}`);
      aborted = true;
      treeKill(pid, "SIGTERM");
    }
  });
  try {
    await commandProcess;
  } catch (processError) {
    if (aborted)
      return;
    if (options?.externalErrorHandler) {
      await options?.externalErrorHandler(processError);
    } else {
      const abortError = new ExternalError(processError.message, command, args);
      abortError.stack = processError.stack;
      throw abortError;
    }
  }
}
function buildExec(command, args, options) {
  const env = options?.env ?? process.env;
  if (shouldDisplayColors()) {
    env.FORCE_COLOR = "1";
  }
  const commandProcess = execa(command, args, {
    env,
    cwd: options?.cwd,
    input: options?.input,
    stdio: options?.stdio,
    stdin: options?.stdin,
    stdout: options?.stdout === "inherit" ? "inherit" : void 0,
    stderr: options?.stderr === "inherit" ? "inherit" : void 0,
    // Setting this to false makes it possible to kill the main process
    // and all its sub-processes with Ctrl+C on Windows
    windowsHide: false
  });
  outputDebug2(`
Running system process:
  \xB7 Command: ${command} ${args.join(" ")}
  \xB7 Working directory: ${options?.cwd ?? cwd2()}
`);
  return commandProcess;
}
function terminalSupportsRawMode(stdin, env = process.env) {
  if (isTruthy(env.CI)) {
    return false;
  }
  if (stdin)
    return Boolean(stdin.isTTY);
  return process.stdin.isTTY;
}

// ../cli-kit/dist/private/node/context/spin-cache.js
init_cjs_shims();
var cachedSpinFQDN;
function getCachedSpinFqdn() {
  return cachedSpinFQDN;
}
function setCachedSpinFqdn(fqdn) {
  cachedSpinFQDN = fqdn;
}

// ../cli-kit/dist/private/node/context/service.js
init_cjs_shims();
var Environment;
(function(Environment2) {
  Environment2["Local"] = "local";
  Environment2["Production"] = "production";
  Environment2["Spin"] = "spin";
})(Environment || (Environment = {}));
function serviceEnvironment(env = process.env) {
  const value = env[environmentVariables.serviceEnv];
  if (value === "local") {
    return Environment.Local;
  } else if (value === "spin" || isSpin(env)) {
    return Environment.Spin;
  } else {
    return Environment.Production;
  }
}

// ../cli-kit/dist/public/node/context/spin.js
var SpinInstanceNotFoundMessages = (spinInstance, error) => {
  const errorMessage = outputContent2`${outputToken.genericShellCommand(`spin`)} yielded the following error trying to obtain the fully qualified domain name of the Spin instance:
${error}
  `;
  let nextSteps;
  if (spinInstance) {
    nextSteps = `Make sure ${spinInstance} is the instance name and not a fully qualified domain name`;
  }
  return { errorMessage, nextSteps };
};
var spinFqdnFilePath = "/etc/spin/machine/fqdn";
async function spinFqdn(env = process.env) {
  let spinFqdn2 = getCachedSpinFqdn();
  if (spinFqdn2)
    return spinFqdn2;
  if (await fileExists(spinFqdnFilePath)) {
    spinFqdn2 = await readFileSync(spinFqdnFilePath).toString();
  } else {
    const spinInstance = await instance(env);
    const showResponse = await show(spinInstance, env);
    spinFqdn2 = showResponse.fqdn;
  }
  setCachedSpinFqdn(spinFqdn2);
  return spinFqdn2;
}
async function show(spinInstance, env = process.env) {
  const latest = spinInstance === void 0;
  const args = latest ? ["show", "--latest", "--json"] : ["show", "--json"];
  const output = await captureOutput("spin", args, { env });
  const json = JSON.parse(output);
  if (json.error) {
    const { errorMessage, nextSteps } = SpinInstanceNotFoundMessages(spinInstance, json.error);
    throw new AbortError(errorMessage, nextSteps);
  } else {
    return json;
  }
}
function isSpin(env = process.env) {
  return isTruthy(env[environmentVariables.spin]);
}
function instance(env = process.env) {
  return env[environmentVariables.spinInstance];
}
function isSpinEnvironment(env = process.env) {
  return serviceEnvironment(env) === Environment.Spin;
}

// ../cli-kit/dist/private/node/context/utilities.js
init_cjs_shims();
function isSet(variable) {
  if (variable === void 0 || variable.trim() === "") {
    return false;
  }
  return true;
}
function getCIMetadata(envName, envs) {
  switch (envName) {
    case "bitbucket":
      return {
        branch: envs.BITBUCKET_BRANCH,
        build: envs.BITBUCKET_BUILD_NUMBER,
        commitSha: envs.BITBUCKET_COMMIT,
        run: envs.BITBUCKET_BUILD_NUMBER,
        url: `https://bitbucket.org/${envs.BITBUCKET_WORKSPACE}/${envs.BITBUCKET_REPO_SLUG}/pipelines/results/${envs.BITBUCKET_BUILD_NUMBER}`
      };
    case "circleci":
      return {
        actor: envs.CIRCLE_USERNAME,
        branch: envs.CIRCLE_BRANCH,
        build: envs.CIRCLE_BUILD_NUM,
        commitSha: envs.CIRCLE_SHA1,
        run: envs.CIRCLE_WORKFLOW_ID,
        url: envs.CIRCLE_BUILD_URL
      };
    case "github":
      return {
        actor: envs.GITHUB_ACTOR,
        attempt: envs.GITHUB_RUN_ATTEMPT,
        branch: envs.GITHUB_REF_NAME,
        build: envs.GITHUB_RUN_ID,
        commitSha: envs.GITHUB_SHA,
        run: envs.GITHUB_RUN_ID,
        runNumber: envs.GITHUB_RUN_NUMBER,
        url: `${envs.GITHUB_SERVER_URL}/${envs.GITHUB_REPOSITORY}/actions/runs/${envs.GITHUB_RUN_ID}`
      };
    case "gitlab":
      return {
        actor: envs.GITLAB_USER_LOGIN,
        branch: envs.CI_COMMIT_REF_NAME,
        build: envs.CI_PIPELINE_ID,
        commitSha: envs.CI_COMMIT_SHA,
        commitMessage: envs.CI_COMMIT_MESSAGE,
        run: envs.CI_RUNNER_ID,
        url: envs.CI_PIPELINE_URL
      };
    case "buildkite":
      return {
        branch: envs.BUILDKITE_BRANCH,
        build: envs.BUILDKITE_BUILD_NUMBER,
        commitSha: envs.BUILDKITE_COMMIT,
        commitMessage: envs.BUILDKITE_MESSAGE,
        run: envs.BUILDKITE_BUILD_NUMBER,
        url: envs.BUILDKITE_BUILD_URL
      };
    default:
      return {};
  }
}

// ../cli-kit/dist/public/node/context/local.js
var import_macaddress = __toESM(require_macaddress(), 1);
function isTerminalInteractive() {
  return isInteractive();
}
function isDevelopment(env = process.env) {
  return env[environmentVariables.env] === "development";
}
function isVerbose(env = process.env) {
  return isTruthy(env[environmentVariables.verbose]) || process.argv.includes("--verbose");
}
async function isShopify(env = process.env) {
  if (Object.prototype.hasOwnProperty.call(env, environmentVariables.runAsUser)) {
    return !isTruthy(env[environmentVariables.runAsUser]);
  }
  const devInstalled = await fileExists(pathConstants.executables.dev);
  return devInstalled || isSpin(env);
}
function isUnitTest(env = process.env) {
  return isTruthy(env[environmentVariables.unitTest]);
}
function analyticsDisabled(env = process.env) {
  return isTruthy(env[environmentVariables.noAnalytics]) || isDevelopment(env);
}
function alwaysLogAnalytics(env = process.env) {
  return isTruthy(env[environmentVariables.alwaysLogAnalytics]);
}
function alwaysLogMetrics(env = process.env) {
  return isTruthy(env[environmentVariables.alwaysLogMetrics]);
}
function firstPartyDev(env = process.env) {
  return isTruthy(env[environmentVariables.firstPartyDev]);
}
function useDeviceAuth(env = process.env) {
  return isTruthy(env[environmentVariables.deviceAuth]) || isCloudEnvironment(env);
}
function isCloudEnvironment(env = process.env) {
  return cloudEnvironment2(env).platform !== "localhost";
}
function cloudEnvironment2(env = process.env) {
  if (isSet(env[environmentVariables.codespaces])) {
    return { platform: "codespaces", editor: true };
  }
  if (isSet(env[environmentVariables.gitpod])) {
    return { platform: "gitpod", editor: true };
  }
  if (isSet(env[environmentVariables.cloudShell])) {
    return { platform: "cloudShell", editor: true };
  }
  if (isSpin(env)) {
    return { platform: "spin", editor: false };
  }
  return { platform: "localhost", editor: false };
}
async function hasGit() {
  try {
    await exec2("git", ["--version"]);
    return true;
  } catch {
    return false;
  }
}
function ciPlatform2(env = process.env) {
  if (isTruthy(env.CI)) {
    let name = "unknown";
    if (isSet(env.BITBUCKET_BUILD_NUMBER)) {
      name = "bitbucket";
    } else if (isTruthy(env.CIRCLECI)) {
      name = "circleci";
    } else if (isSet(env.GITHUB_ACTION)) {
      name = "github";
    } else if (isTruthy(env.GITLAB_CI)) {
      name = "gitlab";
    } else if (isSet(env.BUILDKITE)) {
      name = "buildkite";
    }
    return {
      isCI: true,
      name,
      metadata: getCIMetadata(name, env)
    };
  }
  return {
    isCI: false
  };
}
function opentelemetryDomain(env = process.env) {
  if (isSet(env[environmentVariables.otelURL])) {
    return env[environmentVariables.otelURL];
  }
  return "https://otlp-http-production-cli.shopifysvc.com";
}

// ../cli-kit/dist/public/node/is-global.js
init_cjs_shims();
var _isGlobal;
function currentProcessIsGlobal2(argv = process.argv) {
  if (_isGlobal !== void 0 && !isUnitTest())
    return _isGlobal;
  const path = sniffForPath() ?? cwd2();
  const npmPrefix = execaSync("npm", ["prefix"], { cwd: path }).stdout.trim();
  const binDir = argv[1] ?? "";
  const isLocal = binDir.startsWith(npmPrefix.trim());
  _isGlobal = !isLocal;
  return _isGlobal;
}
function inferPackageManagerForGlobalCLI(argv = process.argv) {
  if (!currentProcessIsGlobal2(argv))
    return "unknown";
  const processArgv = argv[1] ?? "";
  if (processArgv.includes("yarn"))
    return "yarn";
  if (processArgv.includes("pnpm"))
    return "pnpm";
  if (processArgv.includes("bun"))
    return "bun";
  return "npm";
}

// ../cli-kit/dist/public/node/colors.js
init_cjs_shims();

// ../cli-kit/dist/private/node/content-tokens.js
init_cjs_shims();
var ContentToken = class {
  constructor(value) {
    this.value = value;
  }
};
var RawContentToken = class extends ContentToken {
  output() {
    return this.value;
  }
};
var LinkContentToken = class extends ContentToken {
  constructor(value, link2, fallback) {
    super(value);
    this.link = link2;
    this.fallback = fallback;
  }
  output() {
    const text = source_default.green(stringifyMessage(this.value));
    const url2 = this.link ?? "";
    return terminalLink(text, url2, { fallback: () => this.fallback ?? `${text} ( ${url2} )` });
  }
};
var CommandContentToken = class extends ContentToken {
  output() {
    return `\`${source_default.magentaBright(stringifyMessage(this.value))}\``;
  }
};
var JsonContentToken = class extends ContentToken {
  output() {
    try {
      return colorJson(stringifyMessage(this.value) ?? {});
    } catch (_) {
      return JSON.stringify(stringifyMessage(this.value) ?? {}, null, 2);
    }
  }
};
var LinesDiffContentToken = class extends ContentToken {
  output() {
    return this.value.map((part) => {
      if (part.added) {
        return part.value.split(/\n/).filter((line) => line !== "").map((line) => {
          return source_default.green(`+ ${line}
`);
        });
      } else if (part.removed) {
        return part.value.split(/\n/).filter((line) => line !== "").map((line) => {
          return source_default.magenta(`- ${line}
`);
        });
      } else {
        return part.value;
      }
    }).flat();
  }
};
var ColorContentToken = class extends ContentToken {
  constructor(value, color) {
    super(value);
    this.color = color;
  }
  output() {
    return this.color(stringifyMessage(this.value));
  }
};
var ErrorContentToken = class extends ContentToken {
  output() {
    return source_default.bold.redBright(stringifyMessage(this.value));
  }
};
var PathContentToken = class extends ContentToken {
  output() {
    return relativizePath(stringifyMessage(this.value));
  }
};
var HeadingContentToken = class extends ContentToken {
  output() {
    return source_default.bold.underline(stringifyMessage(this.value));
  }
};
var SubHeadingContentToken = class extends ContentToken {
  output() {
    return source_default.underline(stringifyMessage(this.value));
  }
};
var ItalicContentToken = class extends ContentToken {
  output() {
    return source_default.italic(stringifyMessage(this.value));
  }
};

// ../cli-kit/dist/public/node/output.js
import { Writable } from "stream";
var TokenizedString = class {
  constructor(value) {
    this.value = value;
  }
};
var outputToken = {
  raw(value) {
    return new RawContentToken(value);
  },
  genericShellCommand(value) {
    return new CommandContentToken(value);
  },
  json(value) {
    return new JsonContentToken(value);
  },
  path(value) {
    return new PathContentToken(value);
  },
  link(value, link2, fallback) {
    return new LinkContentToken(value, link2, fallback);
  },
  heading(value) {
    return new HeadingContentToken(value);
  },
  subheading(value) {
    return new SubHeadingContentToken(value);
  },
  italic(value) {
    return new ItalicContentToken(value);
  },
  errorText(value) {
    return new ErrorContentToken(value);
  },
  cyan(value) {
    return new ColorContentToken(value, source_default.cyan);
  },
  yellow(value) {
    return new ColorContentToken(value, source_default.yellow);
  },
  magenta(value) {
    return new ColorContentToken(value, source_default.magenta);
  },
  green(value) {
    return new ColorContentToken(value, source_default.green);
  },
  gray(value) {
    return new ColorContentToken(value, source_default.gray);
  },
  packagejsonScript(packageManager, scriptName, ...scriptArgs) {
    return new CommandContentToken(formatPackageManagerCommand(packageManager, scriptName, ...scriptArgs));
  },
  successIcon() {
    return new ColorContentToken("\u2714", source_default.green);
  },
  failIcon() {
    return new ErrorContentToken("\u2716");
  },
  linesDiff(value) {
    return new LinesDiffContentToken(value);
  }
};
function formatPackageManagerCommand(packageManager, scriptName, ...scriptArgs) {
  if (currentProcessIsGlobal2()) {
    return [scriptName, ...scriptArgs].join(" ");
  }
  switch (packageManager) {
    case "pnpm":
    case "bun":
    case "yarn": {
      const pieces = [packageManager, scriptName, ...scriptArgs];
      return pieces.join(" ");
    }
    case "npm": {
      const pieces = ["npm", "run", scriptName];
      if (scriptArgs.length > 0) {
        pieces.push("--");
        pieces.push(...scriptArgs);
      }
      return pieces.join(" ");
    }
    case "unknown": {
      const pieces = [scriptName, ...scriptArgs];
      return pieces.join(" ");
    }
  }
}
function outputContent2(strings, ...keys) {
  let output = ``;
  strings.forEach((string, i) => {
    output += string;
    if (i >= keys.length) {
      return;
    }
    const token = keys[i];
    if (typeof token === "string") {
      output += token;
    } else {
      const enumTokenOutput = token.output();
      if (Array.isArray(enumTokenOutput)) {
        enumTokenOutput.forEach((line) => {
          output += line;
        });
      } else {
        output += enumTokenOutput;
      }
    }
  });
  return new TokenizedString(output);
}
function logLevelValue(level) {
  switch (level) {
    case "trace":
      return 10;
    case "debug":
      return 20;
    case "info":
      return 30;
    case "warn":
      return 40;
    case "error":
      return 50;
    case "fatal":
      return 60;
    default:
      return 30;
  }
}
function currentLogLevel() {
  if (isVerbose()) {
    return "debug";
  } else {
    return "info";
  }
}
function shouldOutput(logLevel) {
  if (isUnitTest()) {
    return false;
  }
  const currentLogLevelValue = logLevelValue(currentLogLevel());
  const messageLogLevelValue = logLevelValue(logLevel);
  return messageLogLevelValue >= currentLogLevelValue;
}
var collectedLogs = {};
function collectLog(key, content) {
  const output = collectedLogs.output ?? [];
  const data = collectedLogs[key] ?? [];
  data.push(stripAnsi(stringifyMessage(content) ?? ""));
  output.push(stripAnsi(stringifyMessage(content) ?? ""));
  collectedLogs[key] = data;
  collectedLogs.output = output;
}
function outputInfo(content, logger = consoleLog) {
  const message = stringifyMessage(content);
  if (isUnitTest())
    collectLog("info", content);
  outputWhereAppropriate("info", logger, message);
}
function outputSuccess(content, logger = consoleLog) {
  const message = source_default.bold(`\u2705 Success! ${stringifyMessage(content)}.`);
  if (isUnitTest())
    collectLog("success", content);
  outputWhereAppropriate("info", logger, message);
}
function outputCompleted(content, logger = consoleLog) {
  const message = `${source_default.green("\u2714")} ${stringifyMessage(content)}`;
  if (isUnitTest())
    collectLog("completed", content);
  outputWhereAppropriate("info", logger, message);
}
function outputDebug2(content, logger = consoleLog) {
  if (isUnitTest())
    collectLog("debug", content);
  const message = source_default.gray(stringifyMessage(content));
  outputWhereAppropriate("debug", logger, `${(/* @__PURE__ */ new Date()).toISOString()}: ${message}`);
}
function outputWarn(content, logger = consoleWarn) {
  if (isUnitTest())
    collectLog("warn", content);
  const message = source_default.yellow(stringifyMessage(content));
  outputWhereAppropriate("warn", logger, message);
}
function outputNewline() {
  console.log();
}
function stringifyMessage(message) {
  if (message instanceof TokenizedString) {
    return message.value;
  } else {
    return message;
  }
}
function consoleLog(message) {
  console.log(withOrWithoutStyle(message));
}
function consoleError(message) {
  console.error(withOrWithoutStyle(message));
}
function consoleWarn(message) {
  console.warn(withOrWithoutStyle(message));
}
function outputWhereAppropriate(logLevel, logger, message, options = { skipUIEvent: false }) {
  if (shouldOutput(logLevel)) {
    if (logger instanceof Writable) {
      logger.write(message);
    } else {
      logger(message, logLevel);
    }
    if (!options?.skipUIEvent)
      recordUIEvent({ type: "output", properties: { content: message } });
  }
}
function withOrWithoutStyle(message) {
  if (shouldDisplayColors()) {
    return message;
  } else {
    return unstyled(message);
  }
}
function unstyled(message) {
  return stripAnsi(message);
}
function shouldDisplayColors(_process = process) {
  const { env, stdout } = _process;
  if (Object.hasOwnProperty.call(env, "FORCE_COLOR")) {
    return isTruthy(env.FORCE_COLOR);
  } else {
    return Boolean(stdout.isTTY);
  }
}

// ../cli-kit/dist/public/node/os.js
function platformAndArch(platform = process.platform, arch = process.arch) {
  let archString;
  if (arch === "x64") {
    archString = "amd64";
  } else if (arch === "ia32") {
    archString = "386";
  } else {
    archString = arch;
  }
  const platformString = platform.match(/^win.+/) ? "windows" : platform;
  return { platform: platformString, arch: archString };
}

// ../cli-kit/dist/public/node/environment.js
init_cjs_shims();
function getEnvironmentVariables() {
  return process.env;
}
function getPartnersToken() {
  return getEnvironmentVariables()[environmentVariables.partnersToken];
}
function getIdentityTokenInformation() {
  const identityToken = getEnvironmentVariables()[environmentVariables.identityToken];
  const refreshToken = getEnvironmentVariables()[environmentVariables.refreshToken];
  if (!identityToken || !refreshToken)
    return void 0;
  return {
    accessToken: identityToken,
    refreshToken
  };
}

// ../cli-kit/dist/public/common/version.js
init_cjs_shims();
var CLI_KIT_VERSION = "3.62.0";

// ../cli-kit/dist/public/node/ruby.js
var import_semver = __toESM(require_semver(), 1);
async function version() {
  const parseOutput = (version2) => version2.match(/ruby (\d+\.\d+\.\d+)/)?.[1];
  return captureOutput(rubyExecutable(), ["-v"]).then(parseOutput).catch(() => void 0);
}
function getRubyBinDir() {
  return getEnvironmentVariables().SHOPIFY_RUBY_BINDIR;
}
function rubyExecutable() {
  const rubyBinDir = getRubyBinDir();
  return rubyBinDir ? joinPath(rubyBinDir, "ruby") : "ruby";
}

// ../cli-kit/dist/public/node/monorail.js
init_cjs_shims();

// ../cli-kit/dist/public/node/http.js
init_cjs_shims();

// ../cli-kit/dist/private/node/api/headers.js
init_cjs_shims();
import https from "https";
var RequestClientError = class extends import_ts_error.ExtendableError {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
};
var GraphQLClientError = class extends RequestClientError {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(message, statusCode, errors) {
    super(message, statusCode);
    this.errors = errors;
    this.stack = void 0;
  }
};
function sanitizedHeadersOutput(headers) {
  const sanitized = {};
  const keywords = ["token", "authorization", "subject_token"];
  Object.keys(headers).forEach((header) => {
    if (keywords.find((keyword) => header.toLocaleLowerCase().includes(keyword)) === void 0) {
      sanitized[header] = headers[header];
    }
  });
  return Object.keys(sanitized).map((header) => {
    return ` - ${header}: ${sanitized[header]}`;
  }).join("\n");
}
function buildHeaders(token) {
  const userAgent = `Shopify CLI; v=${CLI_KIT_VERSION}`;
  const headers = {
    "User-Agent": userAgent,
    "Keep-Alive": "timeout=30",
    // 'Sec-CH-UA': secCHUA, This header requires the Git sha.
    "Sec-CH-UA-PLATFORM": process.platform,
    "Content-Type": "application/json",
    ...firstPartyDev() && { "X-Shopify-Cli-Employee": "1" }
  };
  if (token) {
    const authString = token.match(/^shp(at|ua|ca)/) ? token : `Bearer ${token}`;
    headers["authorization"] = authString;
    headers["X-Shopify-Access-Token"] = authString;
  }
  return headers;
}
async function httpsAgent() {
  return new https.Agent({
    rejectUnauthorized: await shouldRejectUnauthorizedRequests(),
    keepAlive: true
  });
}
async function shouldRejectUnauthorizedRequests() {
  return await serviceEnvironment() !== Environment.Spin;
}

// ../cli-kit/dist/private/node/api/urls.js
init_cjs_shims();
function sanitizeURL(url2) {
  const parsedUrl = new URL(url2);
  if (parsedUrl.searchParams.has("subject_token")) {
    parsedUrl.searchParams.set("subject_token", "****");
  }
  if (parsedUrl.searchParams.has("token")) {
    parsedUrl.searchParams.set("token", "****");
  }
  return parsedUrl.toString();
}

// ../cli-kit/dist/private/node/api.js
init_cjs_shims();
import { performance as performance2 } from "perf_hooks";
var allAPIs = ["admin", "storefront-renderer", "partners", "business-platform", "app-management"];
var interestingResponseHeaders = /* @__PURE__ */ new Set(["cache-control", "content-type", "etag", "x-request-id"]);
async function debugLogResponseInfo({ request, url: url2 }, errorHandler2) {
  const t0 = performance2.now();
  const responseHeaders = {};
  let response = {};
  try {
    response = await request;
    response.headers.forEach((value, key) => {
      if (interestingResponseHeaders.has(key))
        responseHeaders[key] = value;
    });
  } catch (err) {
    if (err instanceof ClientError) {
      if (err.response?.headers) {
        for (const [key, value] of err.response?.headers) {
          if (interestingResponseHeaders.has(key))
            responseHeaders[key] = value;
        }
      }
    }
    if (errorHandler2) {
      throw errorHandler2(err, responseHeaders["x-request-id"]);
    } else {
      throw err;
    }
  } finally {
    const t1 = performance2.now();
    outputDebug(`Request to ${sanitizeURL(url2)} completed in ${Math.round(t1 - t0)} ms
With response headers:
${sanitizedHeadersOutput(responseHeaders)}
    `);
  }
  return response;
}

// ../cli-kit/dist/public/node/http.js
var import_form_data = __toESM(require_form_data(), 1);
function formData() {
  return new import_form_data.default();
}
async function fetch2(url2, init) {
  return runWithTimer("cmd_all_timing_network_ms")(() => debugLogResponseInfo({ url: url2.toString(), request: fetch(url2, init) }));
}
async function shopifyFetch(url2, init) {
  const sanitizedUrl = sanitizeURL(url2.toString());
  const options = {
    ...init ?? {},
    headers: {
      ...await buildHeaders(),
      ...init?.headers ?? {}
    }
  };
  outputDebug2(outputContent2`Sending ${options.method ?? "GET"} request to URL ${sanitizedUrl}
With request headers:
${sanitizedHeadersOutput(options?.headers ?? {})}
`);
  return runWithTimer("cmd_all_timing_network_ms")(async () => {
    return debugLogResponseInfo({ url: url2.toString(), request: fetch(url2, { ...init, agent: await httpsAgent() }) });
  });
}

// ../cli-kit/dist/public/node/monorail.js
var url = "https://monorail-edge.shopifysvc.com/v1/produce";
var MONORAIL_COMMAND_TOPIC = "app_cli3_command/1.12";
var publishedCommandNames = /* @__PURE__ */ new Set();
async function publishMonorailEvent(schemaId, publicData, sensitiveData) {
  const commandName = publicData.command;
  if (commandName && typeof commandName === "string") {
    if (publishedCommandNames.has(commandName)) {
      return { type: "ok" };
    }
    publishedCommandNames.add(commandName);
  }
  try {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const payload = { ...publicData, ...sensitiveData };
    const body = JSON.stringify({ schema_id: schemaId, payload });
    const headers = buildHeaders2(currentTime);
    const response = await fetch2(url, { method: "POST", body, headers });
    if (response.status === 200) {
      outputDebug2(outputContent2`Analytics event sent: ${outputToken.json(sanitizePayload(payload))}`);
      return { type: "ok" };
    } else {
      outputDebug2(`Failed to report usage analytics: ${response.statusText}`);
      return { type: "error", message: response.statusText };
    }
  } catch (error) {
    let message = "Failed to report usage analytics";
    if (error instanceof Error) {
      message = message.concat(`: ${error.message}`);
    }
    outputDebug2(message);
    return { type: "error", message };
  }
}
function sanitizePayload(payload) {
  const result = { ...payload };
  if ("api_key" in result) {
    result.api_key = "****";
  }
  return result;
}
var buildHeaders2 = (currentTime) => {
  return {
    "Content-Type": "application/json; charset=utf-8",
    "X-Monorail-Edge-Event-Created-At-Ms": currentTime.toString(),
    "X-Monorail-Edge-Event-Sent-At-Ms": currentTime.toString()
  };
};

// ../cli-kit/dist/public/node/plugins.js
init_cjs_shims();
async function fanoutHooks(config, event, options, timeout) {
  const res = await config.runHook(event, options, timeout);
  return Object.fromEntries(res.successes.map(({ result, plugin }) => [plugin.name, result]));
}

// ../cli-kit/dist/private/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/crypto.js
init_cjs_shims();
import crypto from "crypto";
function randomHex(size) {
  return crypto.randomBytes(size).toString("hex");
}
function base64URLEncode(str) {
  return str.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/[=]/g, "");
}
function sha256(str) {
  return crypto.createHash("sha256").update(str).digest();
}
function hashString(str) {
  return crypto.createHash("sha1").update(str).digest("hex");
}
function fileHash(buff) {
  return crypto.createHash("md5").update(buff).digest("hex");
}
function randomBytes(size) {
  return crypto.randomBytes(size);
}

// ../cli-kit/dist/public/node/node-package-manager.js
init_cjs_shims();

// ../cli-kit/dist/private/node/conf-store.js
init_cjs_shims();

// ../cli-kit/dist/public/node/local-storage.js
init_cjs_shims();
var LocalStorage = class {
  constructor(options) {
    this.config = new Conf(options);
  }
  /**
   * Get a value from the local storage.
   *
   * @param key - The key to get.
   * @returns The value.
   */
  get(key) {
    return this.config.get(key);
  }
  /**
   * Set a value in the local storage.
   *
   * @param key - The key to set.
   * @param value - The value to set.
   */
  set(key, value) {
    this.config.set(key, value);
  }
  /**
   * Delete a value from the local storage.
   *
   * @param key - The key to delete.
   */
  delete(key) {
    this.config.delete(key);
  }
  /**
   * Clear the local storage (delete all values).
   */
  clear() {
    this.config.clear();
  }
};

// ../cli-kit/dist/private/node/conf-store.js
var _instance2;
function cliKitStore() {
  if (!_instance2) {
    _instance2 = new LocalStorage({ projectName: "shopify-cli-kit" });
  }
  return _instance2;
}
function getSession(config = cliKitStore()) {
  outputDebug(outputContent`Getting session store...`);
  return config.get("sessionStore");
}
function setSession(session, config = cliKitStore()) {
  outputDebug(outputContent`Setting session store...`);
  config.set("sessionStore", session);
}
function removeSession(config = cliKitStore()) {
  outputDebug(outputContent`Removing session store...`);
  config.delete("sessionStore");
}
async function cacheRetrieveOrRepopulate(key, fn, timeout, config = cliKitStore()) {
  const cache = config.get("cache") || {};
  const cached = cache[key];
  if (cached?.value !== void 0 && (timeout === void 0 || Date.now() - cached.timestamp < timeout)) {
    return cached.value;
  }
  const value = await fn();
  cache[key] = { value, timestamp: Date.now() };
  config.set("cache", cache);
  return value;
}

// ../cli-kit/dist/public/node/node-package-manager.js
var import_semver2 = __toESM(require_semver(), 1);
var yarnLockfile = "yarn.lock";
var pnpmLockfile = "pnpm-lock.yaml";
var bunLockfile = "bun.lockb";
var PackageJsonNotFoundError = class extends AbortError {
  constructor(directory) {
    super(outputContent2`The directory ${outputToken.path(directory)} doesn't have a package.json.`);
  }
};
var FindUpAndReadPackageJsonNotFoundError = class extends BugError {
  constructor(directory) {
    super(outputContent2`Couldn't find a a package.json traversing directories from ${outputToken.path(directory)}`);
  }
};
function packageManagerFromUserAgent(env = process.env) {
  if (env.npm_config_user_agent?.includes("yarn")) {
    return "yarn";
  } else if (env.npm_config_user_agent?.includes("pnpm")) {
    return "pnpm";
  } else if (env.npm_config_user_agent?.includes("bun")) {
    return "bun";
  } else if (env.npm_config_user_agent?.includes("npm")) {
    return "npm";
  }
  return "unknown";
}
async function getPackageManager(fromDirectory) {
  const directory = await captureOutput("npm", ["prefix"], { cwd: fromDirectory });
  outputDebug2(outputContent2`Obtaining the dependency manager in directory ${outputToken.path(directory)}...`);
  const packageJson = joinPath(directory, "package.json");
  if (!await fileExists(packageJson)) {
    return packageManagerFromUserAgent();
  }
  const yarnLockPath = joinPath(directory, yarnLockfile);
  const pnpmLockPath = joinPath(directory, pnpmLockfile);
  const bunLockPath = joinPath(directory, bunLockfile);
  if (await fileExists(yarnLockPath)) {
    return "yarn";
  } else if (await fileExists(pnpmLockPath)) {
    return "pnpm";
  } else if (await fileExists(bunLockPath)) {
    return "bun";
  } else {
    return "npm";
  }
}
async function installNodeModules(options) {
  const execOptions = {
    cwd: options.directory,
    stdin: void 0,
    stdout: options.stdout,
    stderr: options.stderr,
    signal: options.signal
  };
  let args = ["install"];
  if (options.args) {
    args = args.concat(options.args);
  }
  await runWithTimer("cmd_all_timing_network_ms")(async () => {
    await exec2(options.packageManager, args, execOptions);
  });
}
async function getDependencies(packageJsonPath) {
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  const dependencies = packageJsonContent.dependencies ?? {};
  const devDependencies = packageJsonContent.devDependencies ?? {};
  return { ...dependencies, ...devDependencies };
}
async function checkForNewVersion(dependency, currentVersion, { cacheExpiryInHours = 0 } = {}) {
  const getLatestVersion = async () => {
    outputDebug2(outputContent2`Checking if there's a version of ${dependency} newer than ${currentVersion}`);
    return getLatestNPMPackageVersion(dependency);
  };
  const cacheKey = `npm-package-${dependency}`;
  let lastVersion;
  try {
    lastVersion = await cacheRetrieveOrRepopulate(cacheKey, getLatestVersion, cacheExpiryInHours * 24 * 1e3);
  } catch (error) {
    return void 0;
  }
  if (lastVersion && new import_semver2.SemVer(currentVersion).compare(lastVersion) < 0) {
    return lastVersion;
  } else {
    return void 0;
  }
}
async function readAndParsePackageJson(packageJsonPath) {
  if (!await fileExists(packageJsonPath)) {
    throw new PackageJsonNotFoundError(dirname2(packageJsonPath));
  }
  return JSON.parse(await readFile(packageJsonPath));
}
async function findUpAndReadPackageJson(fromDirectory) {
  const packageJsonPath = await findPathUp("package.json", { cwd: fromDirectory, type: "file" });
  if (packageJsonPath) {
    const packageJson = JSON.parse(await readFile(packageJsonPath));
    return { path: packageJsonPath, content: packageJson };
  } else {
    throw new FindUpAndReadPackageJsonNotFoundError(fromDirectory);
  }
}
async function getLatestNPMPackageVersion(name) {
  outputDebug2(outputContent2`Getting the latest version of NPM package: ${outputToken.raw(name)}`);
  return runWithTimer("cmd_all_timing_network_ms")(() => {
    return latestVersion(name);
  });
}
async function writePackageJSON(directory, packageJSON) {
  outputDebug2(outputContent2`JSON-encoding and writing content to package.json at ${outputToken.path(directory)}...`);
  const packagePath = joinPath(directory, "package.json");
  await writeFile(packagePath, JSON.stringify(packageJSON, null, 2));
}

// ../cli-kit/dist/private/node/analytics.js
async function getEnvironmentData(config) {
  const ciplatform = ciPlatform();
  const pluginNames = getPluginNames(config);
  const shopifyPlugins = pluginNames.filter((plugin) => plugin.startsWith("@shopify/"));
  const { platform, arch } = platformAndArch();
  return {
    uname: `${platform} ${arch}`,
    env_ci: ciplatform.isCI,
    env_ci_platform: ciplatform.name,
    env_plugin_installed_any_custom: pluginNames.length !== shopifyPlugins.length,
    env_plugin_installed_shopify: JSON.stringify(shopifyPlugins),
    env_shell: config.shell,
    env_web_ide: cloudEnvironment().editor ? cloudEnvironment().platform : void 0,
    env_device_id: hashString(await macAddress()),
    env_cloud: cloudEnvironment().platform,
    env_package_manager: await getPackageManager(cwd()),
    env_is_global: currentProcessIsGlobal()
  };
}
async function getSensitiveEnvironmentData(config) {
  return {
    env_plugin_installed_all: JSON.stringify(getPluginNames(config))
  };
}
function getPluginNames(config) {
  const pluginNames = [...config.plugins.keys()];
  return pluginNames.sort().filter((plugin) => !plugin.startsWith("@oclif/"));
}

// ../cli-kit/dist/private/node/otel-metrics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/types.js
init_cjs_shims();
var MetricInstrumentType;
(function(MetricInstrumentType2) {
  MetricInstrumentType2["Histogram"] = "Histogram";
  MetricInstrumentType2["Counter"] = "Counter";
  MetricInstrumentType2["UpDownCounter"] = "UpDownCounter";
})(MetricInstrumentType || (MetricInstrumentType = {}));

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
init_cjs_shims();
var import_sdk_metrics = __toESM(require_src5(), 1);
var import_core2 = __toESM(require_src3(), 1);
var import_api2 = __toESM(require_src(), 1);

// ../cli-kit/dist/public/node/vendor/otel-js/utils/throttle.js
init_cjs_shims();
function throttle(func, wait, { leading = true, trailing = true } = {}) {
  let lastArgs;
  let result;
  let context;
  let timeout = null;
  let previous = 0;
  function later() {
    previous = leading === false ? 0 : Date.now();
    timeout = null;
    if (lastArgs) {
      result = func.apply(context, lastArgs);
    }
    context = null;
    lastArgs = null;
  }
  return function(...args) {
    const now = Date.now();
    if (!previous && leading === false)
      previous = now;
    const remaining = wait - (now - previous);
    context = this;
    lastArgs = args;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      if (lastArgs) {
        result = func.apply(context, lastArgs);
      }
      context = null;
      lastArgs = null;
    } else if (!timeout && trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
var InstantaneousMetricReader = class extends import_sdk_metrics.MetricReader {
  constructor({ exporter, throttleLimit }) {
    super({
      aggregationSelector: exporter.selectAggregation?.bind(exporter),
      aggregationTemporalitySelector: exporter.selectAggregationTemporality?.bind(exporter)
    });
    this._exporter = exporter;
    this.onForceFlush = throttle(
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.onForceFlush,
      throttleLimit
    );
  }
  async onForceFlush() {
    const { resourceMetrics, errors } = await this.collect({});
    if (errors.length > 0) {
      import_api2.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
    }
    return new Promise((resolve2, reject) => {
      this._exporter.export(resourceMetrics, (result) => {
        if (result.code === import_core2.ExportResultCode.SUCCESS) {
          resolve2();
        } else {
          reject(result.error ?? new Error(`InstantaneousMetricReader: metrics export failed (error ${result.error})`));
        }
      });
    });
  }
  async onShutdown() {
    await this._exporter.shutdown();
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
var import_exporter_metrics_otlp_http = __toESM(require_src6(), 1);
var import_resources = __toESM(require_src4(), 1);
var import_sdk_metrics2 = __toESM(require_src5(), 1);
var import_semantic_conventions = __toESM(require_src2(), 1);
var DefaultMeterProvider = class extends import_sdk_metrics2.MeterProvider {
  constructor({ serviceName, env, throttleLimit, useXhr, otelEndpoint }) {
    super({
      resource: new import_resources.Resource({
        [import_semantic_conventions.SemanticResourceAttributes.SERVICE_NAME]: serviceName
      })
    });
    const opts = {
      // url: OTEL_ENDPOINTS[env as Environment] || OTEL_ENDPOINTS.local,
      // CLI addition
      url: otelEndpoint,
      temporalityPreference: import_sdk_metrics2.AggregationTemporality.DELTA
    };
    if (useXhr) {
      opts.headers = {};
    }
    const exporter = new import_exporter_metrics_otlp_http.OTLPMetricExporter(opts);
    this.addMetricReader(new InstantaneousMetricReader({
      exporter,
      throttleLimit
    }));
    if (env === "dev") {
      this.addMetricReader(new InstantaneousMetricReader({
        exporter: new import_sdk_metrics2.ConsoleMetricExporter(),
        throttleLimit
      }));
    }
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
init_cjs_shims();
var import_sdk_metrics3 = __toESM(require_src5(), 1);

// ../cli-kit/dist/public/node/vendor/otel-js/utils/validators.js
init_cjs_shims();
var import_api3 = __toESM(require_src(), 1);
var validMetricRegex = new RegExp("[^a-zA-Z_][^a-zA-Z0-9_]*");
function isValidMetricName(value) {
  if (validMetricRegex.test(value)) {
    import_api3.diag.warn(`Metric name ${value} contains invalid characters and will be dropped.
    Service Names and metric names must conform to the following regex %c[a-zA-Z_][a-zA-Z0-9_]*`, "color:red");
    return false;
  }
  return true;
}

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
var instrumentationScope = "opentelemetry-js-shopify-web";
var BaseOtelService = class {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({ serviceName, prefixMetric = false, metrics = {}, onRecord, meterProvider }) {
    this.metrics = /* @__PURE__ */ new Map();
    this.recordListeners = /* @__PURE__ */ new Set();
    if (!serviceName) {
      throw new Error("Service name is required.");
    }
    this.serviceName = serviceName;
    this.prefixMetric = prefixMetric;
    if (onRecord)
      this.addOnRecord(onRecord);
    if (!meterProvider) {
      throw new Error("MeterProvider is required.");
    }
    this.meterProvider = meterProvider;
    this.register(metrics);
  }
  getMeterProvider() {
    return this.meterProvider;
  }
  addView(viewOptions) {
    ;
    this.meterProvider._sharedState?.viewRegistry?.addView?.(new import_sdk_metrics3.View(viewOptions));
  }
  record(metricName, value, labels) {
    const recordMetric = this.metrics.get(metricName);
    if (!recordMetric) {
      throw new Error(`Service ${this.serviceName} has no metrics registered for name: ${metricName}. Can't record value for unknown metric.`);
    }
    recordMetric(value, labels);
  }
  registerMetric(metricName, { type, ...options }) {
    if (this.metrics.has(metricName)) {
      return;
    }
    const meter = this.meterProvider.getMeter(instrumentationScope);
    const name = this.prefixMetric ? `${this.serviceName}_${metricName}` : metricName;
    if (!isValidMetricName(name)) {
      return;
    }
    const createInstrument = () => {
      switch (type) {
        case MetricInstrumentType.Counter:
          return meter.createCounter(name, options);
        case MetricInstrumentType.UpDownCounter:
          return meter.createUpDownCounter(name, options);
        case MetricInstrumentType.Histogram: {
          if ("boundaries" in options) {
            this.addView({
              instrumentName: name,
              aggregation: new import_sdk_metrics3.ExplicitBucketHistogramAggregation(options.boundaries, true)
            });
          }
          return meter.createHistogram(name, options);
        }
      }
    };
    this.metrics.set(metricName, (firstValue, firstLabels) => {
      const instrument = createInstrument();
      const record = (value, labels) => {
        const [finalValue, finalLabels] = this.notifyRecordListeners(
          metricName,
          value,
          // ensures an new object is created so we don't mutate the original
          { ...labels }
        );
        if ("record" in instrument) {
          instrument.record(finalValue, finalLabels);
        } else {
          instrument.add(finalValue, finalLabels);
        }
        this.meterProvider.forceFlush({});
      };
      record(firstValue, firstLabels);
      this.metrics.set(metricName, record);
    });
  }
  register(metrics) {
    Object.entries(metrics).forEach(([metricName, options]) => {
      this.registerMetric(metricName, options);
    });
  }
  addOnRecord(onRecord) {
    this.recordListeners.add(onRecord);
    return () => {
      this.recordListeners.delete(onRecord);
    };
  }
  removeOnRecord(onRecord) {
    this.recordListeners.delete(onRecord);
  }
  shutdown() {
    this.metrics.clear();
    this.recordListeners.clear();
    return this.meterProvider.shutdown();
  }
  notifyRecordListeners(metricName, initialValue, initialLabels) {
    return Array.from(this.recordListeners).reduce((recordArgs, listener) => {
      return listener(metricName, ...recordArgs) || recordArgs;
    }, [initialValue, initialLabels]);
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
var import_api4 = __toESM(require_src(), 1);
var DefaultOtelService = class extends BaseOtelService {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({
    throttleLimit = 5e3,
    env = "local",
    serviceName,
    prefixMetric = false,
    metrics = {},
    onRecord,
    meterProvider,
    useXhr = false,
    // CLI addition
    otelEndpoint
  }) {
    import_api4.diag.setLogger(new import_api4.DiagConsoleLogger(), ["production", "staging"].includes(env) ? import_api4.DiagLogLevel.ERROR : import_api4.DiagLogLevel.INFO);
    super({
      serviceName,
      meterProvider: meterProvider ?? new DefaultMeterProvider({
        serviceName,
        env,
        throttleLimit,
        useXhr,
        // CLI addition
        otelEndpoint
      }),
      prefixMetric,
      metrics,
      onRecord
    });
  }
  shutdown() {
    import_api4.diag.disable();
    return super.shutdown();
  }
};

// ../cli-kit/dist/private/node/otel-metrics.js
var import_api5 = __toESM(require_src(), 1);
var Name;
(function(Name2) {
  Name2["Counter"] = "cli_commands_total";
  Name2["Duration"] = "cli_commands_duration_ms";
  Name2["Elapsed"] = "cli_commands_wall_clock_elapsed_ms";
})(Name || (Name = {}));
async function recordMetrics(options, timing, recorderFactory = createMetricRecorder) {
  const recorder = recorderFactory({
    skipMetricAnalytics: options.skipMetricAnalytics,
    otelOptions: defaultOtelOptions()
  });
  let regularisedCliVersion = options.cliVersion;
  if (options.cliVersion.includes("nightly")) {
    regularisedCliVersion = "nightly";
  } else if (options.cliVersion.includes("pre")) {
    regularisedCliVersion = "pre";
  }
  const labels = {
    exit: options.exitMode,
    job: `${options.owningPlugin}::${options.command}`,
    cli_version: regularisedCliVersion
  };
  recordCommandCounter(recorder, labels);
  recordCommandTiming(recorder, labels, timing);
}
function defaultOtelOptions() {
  return {
    serviceName: "shopify-cli",
    throttleLimit: 1e3,
    prefixMetric: false,
    metrics: {
      [Name.Counter]: {
        type: MetricInstrumentType.Counter,
        description: "Total number of CLI commands executed",
        valueType: import_api5.ValueType.INT
      },
      [Name.Duration]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time spent in execution of CLI commands. Does not include time spent waiting for network, prompts, etc.",
        valueType: import_api5.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      },
      [Name.Elapsed]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time elapsed from start to finish of CLI commands. Includes time spent waiting for network, prompts, etc.",
        valueType: import_api5.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      }
    }
  };
}
function createMetricRecorder(options) {
  let recorder = "console";
  if (!(options.skipMetricAnalytics || isUnitTest() || isSpinEnvironment())) {
    recorder = {
      type: "otel",
      otel: globalOtelService(options)
    };
  }
  return recorder;
}
var _otelService;
function globalOtelService(options) {
  if (!_otelService) {
    _otelService = new DefaultOtelService({
      ...options.otelOptions,
      env: void 0,
      otelEndpoint: `${opentelemetryDomain()}/v1/metrics`
    });
  }
  return _otelService;
}
function recordCommandCounter(recorder, labels) {
  if (recorder === "console") {
    outputDebug2(outputContent2`[OTEL] record ${Name.Counter} counter ${outputToken.json({ labels })}`);
    return;
  }
  recorder.otel.record(Name.Counter, 1, labels);
}
function recordCommandTiming(recorder, labels, timing) {
  if (recorder === "console") {
    outputDebug2(outputContent2`[OTEL] record ${Name.Duration} histogram ${timing.active.toString()}ms ${outputToken.json({
      labels
    })}`);
    outputDebug2(outputContent2`[OTEL] record ${Name.Elapsed} histogram stage="active" ${timing.active.toString()}ms`);
    outputDebug2(outputContent2`[OTEL] record ${Name.Elapsed} histogram stage="network" ${timing.network.toString()}ms`);
    outputDebug2(outputContent2`[OTEL] record ${Name.Elapsed} histogram stage="prompt" ${timing.prompt.toString()}ms`);
    return;
  }
  if (timing.active > 0) {
    recorder.otel.record(Name.Duration, timing.active, labels);
    recorder.otel.record(Name.Elapsed, timing.active, { ...labels, stage: "active" });
  }
  if (timing.network > 0) {
    recorder.otel.record(Name.Elapsed, timing.network, { ...labels, stage: "network" });
  }
  if (timing.prompt > 0) {
    recorder.otel.record(Name.Elapsed, timing.prompt, { ...labels, stage: "prompt" });
  }
}

// ../cli-kit/dist/public/node/analytics.js
async function reportAnalyticsEvent(options) {
  try {
    const payload = await buildPayload(options);
    if (payload === void 0) {
      return;
    }
    const skipMonorailAnalytics = !alwaysLogAnalytics() && analyticsDisabled();
    const skipMetricAnalytics = !alwaysLogMetrics() && analyticsDisabled();
    if (skipMonorailAnalytics || skipMetricAnalytics) {
      outputDebug2(outputContent2`Skipping command analytics, payload: ${outputToken.json(payload)}`);
    }
    const doMonorail = async () => {
      if (skipMonorailAnalytics) {
        return;
      }
      const response = await publishMonorailEvent(MONORAIL_COMMAND_TOPIC, payload.public, payload.sensitive);
      if (response.type === "error") {
        outputDebug2(response.message);
      }
    };
    const doOpenTelemetry = async () => {
      const active = payload.public.cmd_all_timing_active_ms || 0;
      const network = payload.public.cmd_all_timing_network_ms || 0;
      const prompt = payload.public.cmd_all_timing_prompts_ms || 0;
      return recordMetrics({
        skipMetricAnalytics,
        cliVersion: payload.public.cli_version,
        owningPlugin: payload.public.cmd_all_plugin || "@shopify/cli",
        command: payload.public.command,
        exitMode: options.exitMode
      }, {
        active,
        network,
        prompt
      });
    };
    await Promise.all([doMonorail(), doOpenTelemetry()]);
  } catch (error) {
    let message = "Failed to report usage analytics";
    if (error instanceof Error) {
      message = message.concat(`: ${error.message}`);
    }
    outputDebug2(message);
  }
}
async function buildPayload({ config, errorMessage, exitMode }) {
  const { commandStartOptions, environmentFlags, ...sensitiveMetadata } = getAllSensitiveMetadata();
  if (commandStartOptions === void 0) {
    outputDebug2("Unable to log analytics event - no information on executed command");
    return;
  }
  const { startCommand, startArgs, startTime } = commandStartOptions;
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  const { "@shopify/cli": internalPluginsPublic, ...externalPluginsPublic } = await fanoutHooks(config, "public_command_metadata", {});
  const { "@shopify/cli": internalPluginsSensitive, ...externalPluginsSensitive } = await fanoutHooks(config, "sensitive_command_metadata", {});
  const environmentData = await getEnvironmentData(config);
  const sensitiveEnvironmentData = await getSensitiveEnvironmentData(config);
  const publicMetadata = getAllPublicMetadata();
  const subTimers = ["cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"];
  const totalTimeFromSubtimers = subTimers.reduce((total, timer) => {
    const value = publicMetadata[timer];
    if (value !== void 0) {
      return total + value;
    }
    return total;
  }, 0);
  const wallClockElapsed = currentTime - startTime;
  const totalTimeWithoutSubtimers = wallClockElapsed - totalTimeFromSubtimers;
  let payload = {
    public: {
      command: startCommand,
      time_start: startTime,
      time_end: currentTime,
      total_time: wallClockElapsed,
      success: exitMode === "ok" && errorMessage === void 0,
      cli_version: CLI_KIT_VERSION,
      ruby_version: await version() || "",
      node_version: process.version.replace("v", ""),
      is_employee: await isShopify(),
      ...environmentData,
      ...internalPluginsPublic,
      ...publicMetadata,
      cmd_all_timing_active_ms: totalTimeWithoutSubtimers,
      cmd_all_exit: exitMode
    },
    sensitive: {
      args: startArgs.join(" "),
      cmd_all_environment_flags: environmentFlags,
      error_message: errorMessage,
      ...internalPluginsSensitive,
      ...sensitiveEnvironmentData,
      metadata: JSON.stringify({
        ...sensitiveMetadata,
        extraPublic: {
          ...externalPluginsPublic
        },
        extraSensitive: { ...externalPluginsSensitive }
      })
    }
  };
  const timingMetrics = ["cmd_all_timing_active_ms", "cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"];
  timingMetrics.forEach((metric) => {
    const current = payload.public[metric];
    if (current !== void 0) {
      payload.public[metric] = Math.floor(current);
    }
  });
  payload = JSON.parse(JSON.stringify(payload));
  return sanitizePayload2(payload);
}
function sanitizePayload2(payload) {
  const payloadString = JSON.stringify(payload);
  const sanitizedPayloadString = payloadString.replace(/shptka_\w*/g, "*****");
  return JSON.parse(sanitizedPayloadString);
}

// ../cli-kit/dist/public/node/error-handler.js
var import_core3 = __toESM(require_lib(), 1);
var import_stacktracey2 = __toESM(require_stacktracey(), 1);
var import_js = __toESM(require_notifier(), 1);
import { realpath } from "fs/promises";
async function errorHandler(error, config) {
  if (error instanceof CancelExecution) {
    if (error.message && error.message !== "") {
      outputInfo(`\u2728  ${error.message}`);
    }
  } else if (error instanceof AbortSilentError) {
    printEventsJson();
  } else {
    return errorMapper(error).then((error2) => {
      return handler(error2);
    }).then((mappedError) => {
      printEventsJson();
      return reportError(mappedError, config);
    });
  }
}
var reportError = async (error, config) => {
  let exitMode = "expected_error";
  if (shouldReportError(error))
    exitMode = "unexpected_error";
  if (config !== void 0) {
    await reportAnalyticsEvent({ config, errorMessage: error instanceof Error ? error.message : void 0, exitMode });
  }
  await sendErrorToBugsnag(error, exitMode);
};
async function sendErrorToBugsnag(error, exitMode) {
  if (import_core3.settings.debug) {
    outputDebug2(`Skipping Bugsnag report`);
    return { reported: false, error, unhandled: void 0 };
  }
  const unhandled = exitMode === "unexpected_error";
  let reportableError;
  let stacktrace;
  let report = false;
  if (error instanceof Error) {
    report = true;
    reportableError = new Error(error.message);
    stacktrace = error.stack;
  } else if (typeof error === "string" && error.trim().length !== 0) {
    report = true;
    reportableError = new Error(error);
    stacktrace = reportableError.stack;
  } else {
    report = false;
    reportableError = new Error("Unknown error");
  }
  const formattedStacktrace = new import_stacktracey2.default(stacktrace ?? "").clean().items.map((item) => {
    const filePath = cleanSingleStackTracePath(item.file);
    return `    at ${item.callee} (${filePath}:${item.line}:${item.column})`;
  }).join("\n");
  reportableError.stack = `Error: ${reportableError.message}
${formattedStacktrace}`;
  if (report) {
    initializeBugsnag();
    await new Promise((resolve2, reject) => {
      outputDebug2(`Reporting ${unhandled ? "unhandled" : "handled"} error to Bugsnag: ${reportableError.message}`);
      const eventHandler = (event) => {
        event.severity = "error";
        event.unhandled = unhandled;
      };
      const errorHandler2 = (error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve2(reportableError);
        }
      };
      import_js.default.notify(reportableError, eventHandler, errorHandler2);
    });
  }
  return { error: reportableError, reported: report, unhandled };
}
function cleanStackFrameFilePath({ currentFilePath, projectRoot, pluginLocations }) {
  const fullLocation = isAbsolutePath(currentFilePath) ? currentFilePath : joinPath(projectRoot, currentFilePath);
  const matchingPluginPath = pluginLocations.filter(({ pluginPath }) => fullLocation.indexOf(pluginPath) === 0)[0];
  if (matchingPluginPath !== void 0) {
    return joinPath(matchingPluginPath.name, relativePath(matchingPluginPath.pluginPath, fullLocation));
  }
  return currentFilePath.replace(/.*node_modules\//, "");
}
async function registerCleanBugsnagErrorsFromWithinPlugins(config) {
  const bugsnagConfigProjectRoot = import_js.default?._client?._config?.projectRoot ?? cwd2();
  const projectRoot = normalizePath(bugsnagConfigProjectRoot);
  const pluginLocations = await Promise.all([...config.plugins].map(async ([_, plugin]) => {
    const followSymlinks = await realpath(plugin.root);
    return { name: plugin.name, pluginPath: normalizePath(followSymlinks) };
  }));
  initializeBugsnag();
  import_js.default.addOnError(async (event) => {
    event.errors.forEach((error) => {
      error.stacktrace.forEach((stackFrame) => {
        stackFrame.file = cleanStackFrameFilePath({ currentFilePath: stackFrame.file, projectRoot, pluginLocations });
      });
    });
    try {
      await addBugsnagMetadata(event, config);
    } catch (metadataError) {
      outputDebug2(`There was an error adding metadata to the Bugsnag report; Ignoring and carrying on ${metadataError}`);
    }
  });
}
async function addBugsnagMetadata(event, config) {
  const publicData = getAllPublicMetadata();
  const { commandStartOptions } = getAllSensitiveMetadata();
  const { startCommand } = commandStartOptions ?? {};
  const { "@shopify/app": appPublic, ...otherPluginsPublic } = await fanoutHooks(config, "public_command_metadata", {});
  const environment = await getEnvironmentData(config);
  const allMetadata = {
    command: startCommand,
    ...appPublic,
    ...publicData,
    ...environment,
    pluginData: otherPluginsPublic
  };
  const appData = {};
  const commandData = {};
  const environmentData = {};
  const miscData = {};
  const appKeys = ["api_key", "partner_id", "project_type"];
  const commandKeys = ["command"];
  const environmentKeys = ["cli_version", "node_version", "ruby_version", "uname"];
  Object.entries(allMetadata).forEach(([key, value]) => {
    if (key.startsWith("app_") || appKeys.includes(key)) {
      appData[key] = value;
    } else if (key.startsWith("cmd_") || commandKeys.includes(key)) {
      commandData[key] = value;
    } else if (key.startsWith("env_") || environmentKeys) {
      environmentData[key] = value;
    } else {
      miscData[key] = value;
    }
  });
  const bugsnagMetadata = {
    "Shopify App": appData,
    Command: commandData,
    Environment: environmentData,
    Misc: miscData
  };
  Object.entries(bugsnagMetadata).forEach(([section, values]) => {
    event.addMetadata(section, values);
  });
}
function initializeBugsnag() {
  if (import_js.default.isStarted()) {
    return;
  }
  import_js.default.start({
    appType: "node",
    apiKey: bugsnagApiKey,
    logger: null,
    appVersion: CLI_KIT_VERSION,
    autoTrackSessions: false,
    autoDetectErrors: false
  });
}

export {
  isTruthy,
  joinPath,
  resolvePath,
  relativePath,
  dirname2 as dirname,
  basename2 as basename,
  extname2 as extname,
  relativizePath,
  moduleDirectory,
  cwd2 as cwd,
  capitalize,
  pluralize,
  linesToColumns,
  camelize,
  hyphenate,
  underscore,
  readFile,
  readFileSync,
  copyFile,
  touchFile,
  writeFile,
  mkdir,
  removeFile,
  rmdir,
  isDirectory,
  fileSize,
  fileSizeSync,
  createFileReadStream,
  moveFile,
  fileExists,
  glob,
  findPathUp,
  sessionConstants,
  AbortController,
  addPublicMetadata,
  addSensitiveMetadata,
  runWithTimer,
  renderInfo,
  renderSuccess,
  renderWarning,
  renderFatalError,
  renderSelectPrompt,
  renderConfirmationPrompt,
  renderTasks,
  renderTextPrompt,
  keypress,
  CancelExecution,
  FatalError2 as FatalError,
  AbortError,
  BugError,
  import_ts_error,
  openURL,
  terminalSupportsRawMode,
  Environment,
  serviceEnvironment,
  spinFqdn,
  isSpinEnvironment,
  isTerminalInteractive,
  isDevelopment,
  firstPartyDev,
  useDeviceAuth,
  hasGit,
  ciPlatform2 as ciPlatform,
  currentProcessIsGlobal2 as currentProcessIsGlobal,
  inferPackageManagerForGlobalCLI,
  outputToken,
  formatPackageManagerCommand,
  outputContent2 as outputContent,
  collectLog,
  outputInfo,
  outputSuccess,
  outputCompleted,
  outputDebug2 as outputDebug,
  outputWarn,
  outputNewline,
  stringifyMessage,
  getPartnersToken,
  getIdentityTokenInformation,
  RequestClientError,
  GraphQLClientError,
  sanitizedHeadersOutput,
  buildHeaders,
  httpsAgent,
  allAPIs,
  debugLogResponseInfo,
  formData,
  fetch2 as fetch,
  shopifyFetch,
  fanoutHooks,
  randomHex,
  base64URLEncode,
  sha256,
  hashString,
  fileHash,
  randomBytes,
  getSession,
  setSession,
  removeSession,
  cacheRetrieveOrRepopulate,
  packageManagerFromUserAgent,
  getPackageManager,
  installNodeModules,
  getDependencies,
  checkForNewVersion,
  readAndParsePackageJson,
  findUpAndReadPackageJson,
  writePackageJSON,
  errorHandler,
  sendErrorToBugsnag,
  cleanStackFrameFilePath,
  registerCleanBugsnagErrorsFromWithinPlugins,
  addBugsnagMetadata
};
//# sourceMappingURL=chunk-PIB2FEJJ.js.map
